<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>更改hexo博客中的Mathjax引擎</title>
      <link href="/2018/10/14/%E6%9B%B4%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84Mathjax%E5%BC%95%E6%93%8E/"/>
      <url>/2018/10/14/%E6%9B%B4%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84Mathjax%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建的博客在使用Math引擎构建数学公式的时候遇到了几个问题。</p><ul><li>显示公式出错，显示的是语法错误</li><li>不能使用<code>$...$</code>行内公式</li><li>显示的公式十分丑</li></ul><p>在网上也看到了很多的答案，但是都不是很靠谱啊。真的是个大坑啊啊啊，看<a href="https://docs.mathjax.org/en/latest/mathjax.html" target="_blank" rel="noopener">官方文档</a>看了好久，然后又去找的Hexo的实现方法。emmm，索性解决了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="关闭hexo本身的mathjax"><a href="#关闭hexo本身的mathjax" class="headerlink" title="关闭hexo本身的mathjax"></a>关闭hexo本身的mathjax</h3><p>关闭hexo本身的mathjax，也就是在HEXO目录下的_config.yml，改为<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>然后关闭相应文章的<code>front-matter</code>中的<code>mathjax: true</code></p><h3 id="修改主题模板"><a href="#修改主题模板" class="headerlink" title="修改主题模板"></a>修改主题模板</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd themes<span class="regexp">/maupassant/</span></span><br><span class="line"><span class="comment"># 找到head的配置文件，我的模板中head等的配置文件是在这里，其他的可以自己找找</span></span><br><span class="line">cd layout<span class="regexp">/_partial/</span></span><br><span class="line"><span class="comment"># 由于我的主题中的配置文件是pug格式</span></span><br><span class="line">vim head.pug</span><br></pre></td></tr></table></figure><p>然后就在其中加入我们需要的mathjax<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">script(type=<span class="string">"text/x-mathjax-config"</span>).</span><br><span class="line">    <span class="symbol">MathJax</span>.<span class="symbol">Hub</span>.<span class="symbol">Config</span>(&#123;</span><br><span class="line">    extensions: [<span class="string">"tex2jax.js"</span>],</span><br><span class="line">    jax: [<span class="string">"input/TeX"</span>, <span class="string">"output/HTML-CSS"</span>],</span><br><span class="line">    tex2jax: &#123;</span><br><span class="line">        inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span><br><span class="line">        displayMath: [ [<span class="string">'$$'</span>,<span class="string">'$$'</span>], [<span class="string">"\\["</span>,<span class="string">"\\]"</span>] ],</span><br><span class="line">        processEscapes: true</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="string">"HTML-CSS"</span>: &#123; fonts: [<span class="string">"TeX"</span>] &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">script(type=<span class="string">"text/javascript"</span> src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"</span>)</span><br></pre></td></tr></table></figure></p><p>因为pug格式和html相似，因此如果格式是html的话，可以自己更改一下。</p><h3 id="只修改mathjax-pug"><a href="#只修改mathjax-pug" class="headerlink" title="只修改mathjax.pug"></a>只修改mathjax.pug</h3><p>在某些模板中，有着自己的mathjax.pug，那么只需要更改成为以上的mathjax的pug的代码即可。</p><h2 id="修改前后对比"><a href="#修改前后对比" class="headerlink" title="修改前后对比"></a>修改前后对比</h2><h3 id="修改前"><a href="#修改前" class="headerlink" title="修改前"></a>修改前</h3><p><img src="/2018/10/14/更改hexo博客中的Mathjax引擎/E7217D6653FB277C412019A200AE3D19.png" alt="修改前的0-1损失函数" title="修改前的0-1损失函数"></p><h3 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h3><p>$$L(Y,f(x))=\begin{cases}<br>    1,&amp; Y \ne f(X)\\<br>    0,&amp; Y = f(X)<br>\end{cases}$$</p>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac配置ssh免密登录腾讯云服务器</title>
      <link href="/2018/10/13/mac%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/10/13/mac%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在前一段时间，斥巨资购买了一年的云服务器，但是一直落着吃灰，今天忽然想起来折腾一下。</p><p><br></p><h2 id="ssh直连"><a href="#ssh直连" class="headerlink" title="ssh直连"></a>ssh直连</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i ~/.ssh/<span class="string">[密钥名称]</span> <span class="string">[账户]</span>@<span class="string">[ip地址]</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-165116.png" alt="连接上的效果" title="连接上的效果"></p><p>可以看到我们已经连接上了腾讯云服务器，但是是不是每次都需要输入很长的ip地址，这就很烦了，因此接下来我们设置一下hosts，用代号替换ip地址。</p><h2 id="设置hosts"><a href="#设置hosts" class="headerlink" title="设置hosts"></a>设置hosts</h2><p>以下以mac osx系统为例<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure></p><p>然后直接在最后加上你的云服务器ip地址和想要表示的名字。<br>或者用下面的语句直接添加：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"[ip地址]  [替代名]"</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-165910.png" alt="修改后的样子" title="修改后的样子"></p><h3 id="设置免密登录"><a href="#设置免密登录" class="headerlink" title="设置免密登录"></a>设置免密登录</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd .ssh</span><br><span class="line"><span class="variable">$ </span>ssh-keygen</span><br><span class="line"><span class="variable">$ </span>ssh-copy-id ubuntu<span class="variable">@t_cloud</span></span><br></pre></td></tr></table></figure><p>首先进入.ssh目录，生成密钥，然后将公钥传给云服务器。注意：在腾讯云服务器中，默认的用户是ubuntu，而不是root。</p><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-170408.png" alt="密钥传送完毕" title="密钥传送完毕"></p><p>最后尝试免密登录吧</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> ubuntu<span class="variable">@t_cloud</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-170625.png" alt="免密登录成功" title="免密登录成功"></p><p>这样就免密登录成功了，再也不需要繁琐的输入密码了！</p>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《统计学习方法》概论整理</title>
      <link href="/2018/10/04/2018-10-04-%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%A6%82%E8%AE%BA%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/04/2018-10-04-%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%A6%82%E8%AE%BA%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在导师的推荐下，本人开始阅读李航博士的<code>《统计学习方法》</code>，该书是以内容短小精悍著称，因此我也从此书开始正式进入了机器学习的学习阶段。当然在这一节中，本人只是对该章节知识点进行梳理，由于多是基本知识点，所以量很大，内容也很多。</p><h2 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h2><h3 id="统计学习的概念"><a href="#统计学习的概念" class="headerlink" title="统计学习的概念"></a>统计学习的概念</h3><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行<code>预测与分析</code>的一门学科，统计学习也称为统计机器学习。<br></p><h3 id="统计学习的对象"><a href="#统计学习的对象" class="headerlink" title="统计学习的对象"></a>统计学习的对象</h3><p>统计学习的对象是<code>数据</code>，它从数据出发，提取数据的特征，抽象出数据的模型，从数据中发现知识，又回到对数据的分析与预测中去。</p><h3 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h3><p>统计学习由监督学习(supervised learning)、非监督学习(unsupervised learning)、半监督学习(semi-supervised learning)、强化学习(reinforcement learning)等组成。</p><h3 id="统计学习中的常用概念"><a href="#统计学习中的常用概念" class="headerlink" title="统计学习中的常用概念"></a>统计学习中的常用概念</h3><ul><li>我们认为要学习的模型属于某个函数的集合，该集合被称为<code>假设空间</code>。<br></li><li>训练数据、测试数据：意如其名。<br></li><li>统计学习方法的三要素为<code>模型(model)</code>、<code>策略(strategy)</code>、<code>算法(algorithm)</code>。</li></ul><h3 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h3><blockquote><p>(1) 得到一个有限的训练数据集合；<br><br>(2) 确定包含所有可能的模型的假设空间，即学习的模型的集合；<br><br>(3) 确定模型选择的准则，即学习的策略；<br><br>(4) 实现求解最优模型的算法，即学习的算法；<br><br>(5) 通过学习方法选择最优模型；<br><br>(6) 利用学习的最优模型对新数据进行预测或分析；</p></blockquote><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="监督学习的概念"><a href="#监督学习的概念" class="headerlink" title="监督学习的概念"></a>监督学习的概念</h3><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同）<br></p><p>本人认为，”<code>这里的输入、输出</code>“指的不是特征值，而仅仅只是指代系统需要输入输出样本。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>输入空间、特征空间与输出空间</strong><br><br>首先，输入空间与输出空间指的是输入输出所有的可能取值的集合。输入与输出空间可以是有限元素的集合，也可以是整个欧式空间，两者可以是指同一个空间，也可以是不同的空间，通常情况下，输出空间远远小于输入空间。<br><br>每个具体的输入是一个实例，通常由特征向量来表示，此时所有的特征向量存在的空间称为特征空间。特征空间的每一维对应于一个特征。</li><li><strong>联合概率分布</strong><br><br>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X,Y)，P(X,Y)表示分布函数，或者称分布密度函数。</li><li><strong>假设空间</strong><br><br>模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定。</li></ul><h2 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h2><p>$$方法=模型+策略+算法$$</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在监督学习中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。<br><br>假设空间用$\mathcal{F}$表示，假设空间可以定义为决策函数的集合：<br></p><p>$$ \mathcal{F}=\{f|Y=f(X)\} $$</p><p>其中，X和Y是定义在输入空间$\mathcal{X}$和输出空间$\mathcal{Y}$上的变量，这时$\mathcal{F}$通常是由一个参数向量决定的函数族：<br></p><p>$$\mathcal{F}=\{ f|Y=f_\theta(X),\theta\in R^n \}$$</p><p>参数向量$\theta$取值与n维欧式空间$R^n$，称为参数空间。<br></p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>统计学习的<code>目标</code>在于从假设空间中选取<strong>最优模型</strong>。首先需要引入损失函数与风险函数的概念，损失函数度量模型<code>一次预测</code>的好坏，风险函数度量<code>平均意义下</code>的模型预测的好坏。两者的区别就在于一次预测和平均意义。</p><h4 id="损失函数和风险函数（重要）"><a href="#损失函数和风险函数（重要）" class="headerlink" title="损失函数和风险函数（重要）"></a><strong>损失函数和风险函数（重要）</strong></h4><p>监督学习问题是在假设空间$\mathcal{F}$中选取模型$f$作为决策函数，对于给定的输入$X$,由$f(X)$给出相应的输出$Y$，这个输出的预测值$f(X)$与真实值$Y$可能一致也可能不一致，因此需要一个损失函数(loss function)或代价函数(cost function)来度量预测错误的程度，损失函数是$f(X)$和$Y$的非负实值函数，记作为$L(Y,f(X))$.<br>统计学习常用的损失函数有以下几种：</p><ul><li><p>0-1损失函数（0-1 loss function）<br></p><p>  $$L(Y,f(x))=\begin{cases}<br>  1,&amp; Y \ne f(X)\\<br>  0,&amp; Y = f(X)<br>  \end{cases}$$</p></li><li><p>平方损失函数（quadratic loss function）</p><p>$$L(Y,f(X))=(Y-f(X))^2$$</p></li><li><p>绝对损失函数（absolute loss function）</p><p>$$L(Y,f(X))=|Y-f(X)|$$</p></li><li><p>对数损失函数（logarithmic loss function）或对数似然损失函数（log-likelihood loss function）</p><p>$$L(Y,P(Y|X))=-log(P(Y|X))$$</p></li></ul><p>损失函数值越小，模型就越好，由于模型的输入、输出是随机变量，遵循联合分布$P(X,Y)$所以损失函数的期望是:<br></p><p>$$R_{exp}(f)=E_p[L(Y,f(X))]= \lmoustache_{x \times y}L(y,f(x))P(x,y)dxdy$$</p><p>这就是理论上模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失，称为风险函数或期望损失。<br>由于联合分布是未知的，因此$R_exp(f)$不能直接计算，如果知道了联合分布那也就不需要学习了，一方面根据期望风险最小来学习模型要用到联合分布，而联合分布却是未知的，因此我们需要引入一个<code>经验风险</code>的概念，其实模型f(x)关于训练数据集的平均损失，记作$R_{emp}$</p><p>$$R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))   \qquad$$</p><p>注：上式子中，N代表着训练集中的样本数量</p><h4 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a><strong>经验风险最小化与结构风险最小化</strong></h4><p>在经验风险最小化的策略中，我们需要的是求解上述经验风险的最小化，就是求解最优化问题：<br></p><p>$$min_{f\in \mathcal{F}}  \frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))\qquad$$</p><p>当样本容量足够大的时候，经验风险最小化有着很好的效果，因此被广泛采用。<br>当样本容量很小的时候，经验风险最小化学习的效果就未必很好，可能还会有过拟合的情况发生。结构风险最小化就是为了防止过拟合而提出来的策略，结构风险最小化等价于<strong>正则化</strong>，结构风险是在经验风险上加了表示模型复杂度的正则化项（或者称为罚项），在假设空间、损失函数、训练数据集确定的时候，<strong>结构风险</strong>的定义是</p><p>$$R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><ul><li>$J(f)$为模型的复杂度，是定义在假设空间$\mathcal{F}$上的反函数，模型$f$越复杂，复杂度$J(f)$就越大。</li><li>$\lambda$是系数，泳衣权衡经验风险和模型复杂度。</li></ul><p>结构风险最小化策略认为结构风险最小的模型是最优的模型，所以最优模型，就是求解最优化的问题:<br></p><p>$$min_{f\in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><p>在这时，监督学习问题就变成了经验风险或结构风险函数的最优化问题。</p><h4 id="公式整理"><a href="#公式整理" class="headerlink" title="公式整理"></a><strong>公式整理</strong></h4><table><thead><tr><th>风险名称</th><th>损失函数</th><th>最优化</th></tr></thead><tbody><tr><td>期望风险</td><td>$R_{exp}(f)=E_p[L(Y,f(X))]= \lmoustache_{x \times y}L(y,f(x))P(x,y)dxdy$</td><td>不可求</td></tr><tr><td>经验风险</td><td>$ R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))   \qquad $</td><td>$min_{f\in \mathcal{F}}R_{emp}(f)  $</td></tr><tr><td>结构风险</td><td>$R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$</td><td>$min_{f\in \mathcal{F}}R_{srm}(f)  $</td></tr></tbody></table><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是指学习模型的具体计算方法。按照以上所讲，统计学习问题归结为最优化问题，统计学习的算法称为求解最优化问题的算法，通过数值计算的方法求解，来保证找到全局最优解。</p><p>统计学习方法之间的不同，主要来自其模型、策略、算法的不同，若三者确定，统计学习的方法也就随之确定，因此称其为统计学习的三要素。</p><h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h3><p>当损失函数给定时，基于损失函数的模型的训练误差和模型的测试误差就自然成为学习方法评估的标准，注意，统计学习方法具体采用的损失函数未必是评估时使用的损失函数，当然，让两者一致是比较理想的。</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>如果一味地追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种情况呗称为过拟合。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但是对未知数据预测得很差的现象。</p><h2 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h2><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化是结构风险最小化策略的实现，是在经验风险上加上正则化项和罚项。正则化项一般是模型复杂度的<code>单调递增函数</code>，也就是模型越复杂，正则化值越大，LOSS值也就越大。</p><p>正则化的一般形式：</p><p>$$min_{f\in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><p>正则化项有着不同的形式，一般是与参数向量有关，经常使用范数来表示。</p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>这里就需要引入一个范数的概念了。</p><p>L0范数：实际上表示的为向量中非零元素的个数</p><p>$$L0(x)= ^0 \sqrt{\sum_{i=1}^n|x_i|^0}$$</p><ul><li>L1范数：又被称为曼哈顿距离、最小绝对误差等</li></ul><p>$$L1(X)=\sum_{i=1}^n|x_i|$$</p><ul><li>L2范数：又被称为欧式距离，是用的最多的距离度量</li></ul><p>$$L2(X)=\sqrt{\sum_{i=1}^n|x_i|^2}$$</p><p>范数在numpy中有具体的实现方法：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下列语句可以实现求解a向量与b向量之间的距离</span></span><br><span class="line">np.linalg.norm(<span class="keyword">a</span>-b)</span><br></pre></td></tr></table></figure></p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>生成方法是由数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布$P(X|Y)$作为预测的模型。这就是生成模型：</p><p>$$P(X|Y)=\frac{P(X,Y)}{P(X)}$$</p><p>该方法之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。</p><h3 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h3><p>判别方法是数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别模型关心的是对给定的输入，应该预测什么样的输出。</p><h3 id="生成方法和判别方法的特点比较"><a href="#生成方法和判别方法的特点比较" class="headerlink" title="生成方法和判别方法的特点比较"></a>生成方法和判别方法的特点比较</h3><p>生成方法的特点：</p><ul><li>生成方法可以还原出联合概率分布$P(X,Y)$，而判别方法不能；</li><li>生成方法的学习收敛速度更快，模型可以更快地收敛于真实模型</li><li>当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。</li></ul><p>判别方法的特点：</p><ul><li>判别方法直接学习的是条件概率$P(Y|X)$或决策函数$f(X)$</li><li>直接面对预测，往往学习的准确率更高。</li><li>由于直接学习$P(Y|X)或$f(X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</li></ul><h2 id="针对分类问题的指标（重要）"><a href="#针对分类问题的指标（重要）" class="headerlink" title="针对分类问题的指标（重要）"></a>针对分类问题的指标（重要）</h2><p>对二分类问题常用的评价指标是精准率和召回率。通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4中情况出现的总数分别记作：</p><ul><li>TP——将正类预测为正类的数量</li><li>FN——将正类预测为负类的数量</li><li>FP——将负类预测为正类的数量</li><li>TN——将负类预测为负类的数量</li></ul><p>精准率的定义为$P=\frac{TP}{TP+FP}$，可以记为判断为正类的样本中的真实正类的比重。</p><p>召回率的定义为$R=\frac{TP}{TP+FN}$，可以记为真实的正类被判定为正类的比重。</p><p>$F_1$值，是精确率和召回率的调和均值，即$\frac{2}{F_1}=\frac{1}{P}\frac{1}{R}$，$F_1=\frac{2TP}{2TP+FP+FN}$，因此可以看出，当精准率和召回率都高的时候，$F1$值才会高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节主要讲的都是统计学习中的一些基本概念，这份整理也花了不少的时间，应该理解深刻。从下一章开始，进入了十个算法的学习，并且每章都会在理论的基础上配上代码实现，尽请期待了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络实践课程设计——五子棋</title>
      <link href="/2018/09/18/2018-09-18-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/18/2018-09-18-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="游戏形式"><a href="#游戏形式" class="headerlink" title="游戏形式"></a>游戏形式</h2><p>本游戏是通过socket来进行五子棋游戏，我们的形式是<code>一台server</code>开启之后可以支持尽可能多的<code>客户端</code>运行。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li><p><code>server</code></p><ul><li><code>net</code>：socket通信相关功能<ul><li>Action:解析socket传来的指令后进行的执行操作</li><li>EndDeal:游戏结束后的相关处理</li><li>Resolve：对收到的指令（字符串）进行解析处理</li><li>ServerThread：针对多个客户端，开启多个线程支持</li></ul></li><li><code>tool</code><ul><li>FightManager：下棋对战时的相关信息</li><li>HashMapManager：存储对战时配对上的map组合</li><li>MessageManager：用于进行消息管理，包括信息的发送等等</li><li>Player：存储玩家的个人信息</li><li><code>check</code>:进行游戏状态的检测<ul><li>check:检测胜负</li><li>checkX&amp;Y:横纵检测状态</li><li>checkM&amp;N:斜着检测状态</li></ul></li></ul></li><li><code>ui</code>：ui界面<ul><li>ClientPanel:客户端列表版面</li><li>MatchsPanel：配对连接版面</li><li>MessagePanel：消息显示版面</li><li>ServerFrame：服务器主窗口</li></ul></li><li>Server.java:主程序</li></ul></li><li><p><code>client</code></p><ul><li><code>data</code><ul><li>Data:存储玩家自己的相关信息，包括ID、昵称、配对对象等等</li></ul></li><li><code>image</code>：相关的图片，用于表示棋子等</li><li><code>listener</code>：用于监听相关的操作<ul><li>BackListener：悔棋操作</li><li>ChallengeListener：挑战操作</li><li>ConnectListener：登录操作</li><li>ListListener：列表双击操作</li><li>MapListener：监听棋盘</li><li>MessageListener：监听消息发送</li><li>NameListener：重命名操作</li><li>QuitListener：退出操作</li><li>RestartListener：重新开始操作</li><li>StartListener：游戏开始</li></ul></li><li><code>manager</code><ul><li>IOManager:输入输出流</li><li>ListManager:管理玩家列表</li><li>MessageManager：管理消息</li></ul></li><li><code>net</code><ul><li>Connect：登录服务器</li><li>PlayChess：游戏落字传输</li><li>Receive：接收数据线程</li><li>Resolve：解析数据</li></ul></li><li><code>ui</code><ul><li>ChessBoardCanvas：棋盘画板</li><li>FunctionPanel：功能区</li><li>GameFrame：游戏主界面</li><li>GamePanel：左边游戏区</li><li>MessagePanel：消息面板</li><li>OperationPanel：操作面板</li><li>PlayerPanel：玩家面板</li></ul></li><li>QuinterGame：客户端启动</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课设记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jekyll框架搭建</title>
      <link href="/2018/09/16/2018-09-16-MAC_OSX%E4%B8%8A%E5%AE%89%E8%A3%85jekyll/"/>
      <url>/2018/09/16/2018-09-16-MAC_OSX%E4%B8%8A%E5%AE%89%E8%A3%85jekyll/</url>
      
        <content type="html"><![CDATA[<p>1.安装ruby(mac上自带，此步可以跳过)</p><p>2.安装jekyll</p><ul><li><p>安装jekyll</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> jekyll</span><br></pre></td></tr></table></figure></li><li><p>顺利地安装完成之后，可以生成自己的一个博客</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jekyll <span class="keyword">new</span> myBlog</span><br></pre></td></tr></table></figure></li><li><p>接下来尝试进入博客运行一下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myBlog</span><br><span class="line">jekyll <span class="keyword">server</span></span><br></pre></td></tr></table></figure></li><li><p>hin难受，果然报了个错！！！错误输出如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Ruby.framework<span class="regexp">/Versions/</span><span class="number">2.3</span><span class="regexp">/usr/</span>lib<span class="regexp">/ruby/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/rubygems/</span>core_ext/kernel_require.<span class="string">rb:</span><span class="number">55</span>:<span class="keyword">in</span> <span class="string">'require'</span>: cannot load such file -- bundler (LoadError)</span><br><span class="line">from <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Ruby.framework<span class="regexp">/Versions/</span><span class="number">2.3</span><span class="regexp">/usr/</span>lib<span class="regexp">/ruby/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/rubygems/</span>core_ext/kernel_require.<span class="string">rb:</span><span class="number">55</span>:<span class="keyword">in</span> <span class="string">'require'</span></span><br><span class="line">from <span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/gems/</span>jekyll<span class="number">-3.8</span><span class="number">.3</span><span class="regexp">/lib/</span>jekyll/plugin_manager.<span class="string">rb:</span><span class="number">48</span>:<span class="keyword">in</span> <span class="string">'require_from_bundler'</span></span><br><span class="line">from <span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/gems/</span>jekyll<span class="number">-3.8</span><span class="number">.3</span><span class="regexp">/exe/</span><span class="string">jekyll:</span><span class="number">11</span>:<span class="keyword">in</span> <span class="string">'&lt;top (required)&gt;'</span></span><br><span class="line">from <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span><span class="string">jekyll:</span><span class="number">22</span>:<span class="keyword">in</span> <span class="string">'load'</span></span><br><span class="line">from <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span><span class="string">jekyll:</span><span class="number">22</span>:<span class="keyword">in</span> <span class="string">'&lt;main&gt;'</span></span><br></pre></td></tr></table></figure></li><li><p>接下来就是上网找了找如何解决该问题，因为笔者也是小白，第一次搭博客，所幸找到了解决方案，感激！解决办法如下：</p></li><li><p>安装bundle</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install </span><span class="keyword">bundle</span></span><br><span class="line"><span class="keyword">gem </span><span class="keyword">install </span>minima</span><br><span class="line">gem <span class="keyword">install </span><span class="keyword">jekyll-feed</span></span><br></pre></td></tr></table></figure></li><li><p>本以为完成了，就开心的开启了一下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>exec <span class="keyword">jekyll </span>serve</span><br></pre></td></tr></table></figure></li><li><p>但是！但是！但是！它又报了一个错！</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could <span class="keyword">not</span> <span class="builtin-name">find</span> public_suffix-3.0.0 <span class="keyword">in</span> any of the sources</span><br><span class="line"><span class="builtin-name">Run</span> `bundle install` <span class="keyword">to</span> install missing gems.</span><br></pre></td></tr></table></figure></li><li><p>好的是，只要我们认真听话的执行一下提示代码就可以了！</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>install</span><br></pre></td></tr></table></figure></li><li><p>然后等待全部安装完成</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Bundle complete! <span class="number">4</span> Gemfile dependencies, <span class="number">23</span> gems now installed.</span><br><span class="line">Use `bundle info [gemname]` to see <span class="keyword">where</span> a bundled gem is installed.</span><br></pre></td></tr></table></figure></li><li><p>最后启动！</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>exec <span class="keyword">jekyll </span>serve</span><br></pre></td></tr></table></figure></li><li><p>然后打开<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> ，就能完美的看到自己的博客啦，jekyll就已经安装完成咯。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018华为秋招笔试</title>
      <link href="/2018/08/30/2018%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
      <url>/2018/08/30/2018%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>徘徊在保研与不保研之间，看了考研书感觉自己根本看不下去，看实验室同学都去了华为，因此就像报名了华为的秋招，报名了大数据开发岗，<del>由于之前参加比赛学过hadoop等大数据框架</del>，所以报了试试看，前几天通知了笔试，于是就去水了一波。</p><h2 id="笔试介绍"><a href="#笔试介绍" class="headerlink" title="笔试介绍"></a>笔试介绍</h2><p>华为今年的笔试和去年形式差不多，三道编程题，分值分别是100、200、300，语言基本上都可以使用，题目自我感觉很简单，因为都是一遍AC了，一个小时就解决了，hhh，就不吹了，下面记录记录题目和我的代码。</p><h3 id="字符串处理题"><a href="#字符串处理题" class="headerlink" title="字符串处理题"></a>字符串处理题</h3><p>题目是从一个字符串中找到所有存在的整数，包括负号，且负号可累计，然后将寻找到的整数相加即可，下面是代码：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">import sys</span><br><span class="line">numlist= [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">10</span>))]</span><br><span class="line"><span class="comment"># print(numlist)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> sys.<span class="keyword">stdin</span>:</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">line</span>.<span class="built_in">split</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">a</span>:</span><br><span class="line">        flag=True<span class="comment">#当前数字为正</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span><span class="comment">#当前和</span></span><br><span class="line">        <span class="built_in">num</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">char</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">char</span> == <span class="string">'-'</span>:</span><br><span class="line">                flag=<span class="keyword">not</span> flag</span><br><span class="line">            elif <span class="keyword">char</span> <span class="keyword">in</span> numlist:</span><br><span class="line">                <span class="comment">#数字处理</span></span><br><span class="line">                    <span class="built_in">num</span>=<span class="built_in">num</span>*<span class="number">10</span>+int(<span class="keyword">char</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="built_in">sum</span>+=<span class="built_in">num</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">sum</span>-=<span class="built_in">num</span></span><br><span class="line">                <span class="comment"># sum+=num</span></span><br><span class="line">                <span class="comment"># print(sum)</span></span><br><span class="line">                <span class="built_in">num</span>=<span class="number">0</span></span><br><span class="line">                flag=True</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">sum</span>+=<span class="built_in">num</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">sum</span>-=<span class="built_in">num</span></span><br><span class="line">        print(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure></p><h3 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h3><p>题目是需要按照给定的规则，来计算带有复数的卷积，卷积定义网上也有，我就不赘述了，直接开模拟，代码如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">import sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fuNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x,y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.r=x</span><br><span class="line">        <span class="keyword">self</span>.im=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r + b.r, <span class="keyword">self</span>.im + b.im)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r - b.r, <span class="keyword">self</span>.im - b.im)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mult</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r * b.r - <span class="keyword">self</span>.im * b.im, b.r * <span class="keyword">self</span>.im + <span class="keyword">self</span>.r * b.im)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">"__main__"</span><span class="symbol">:</span></span><br><span class="line">    duoa=[]</span><br><span class="line">    duob=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 读取每一行</span></span><br><span class="line">        r = eval(sys.stdin.readline().strip())</span><br><span class="line">        im= eval(sys.stdin.readline().strip())</span><br><span class="line">        duoa.append(fuNum(r,im))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 读取每一行</span></span><br><span class="line">        r = eval(sys.stdin.readline().strip())</span><br><span class="line">        im= eval(sys.stdin.readline().strip())</span><br><span class="line">        duob.append(fuNum(r,im))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)<span class="symbol">:</span></span><br><span class="line">        duoa.append(fuNum(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        duob.append(fuNum(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># n=4</span></span><br><span class="line">    duoc=[]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">9</span>)<span class="symbol">:</span></span><br><span class="line">        temp=fuNum(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">            <span class="comment"># print(k,n)</span></span><br><span class="line">            temp=temp.add(duoa[k].mult(duob[n-k]))</span><br><span class="line">        <span class="comment"># print(temp.r,temp.im)</span></span><br><span class="line">        duoc.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(duoc)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="symbol">duoc:</span></span><br><span class="line">        print(i.r)</span><br><span class="line">        print(i.im)</span><br></pre></td></tr></table></figure></p><h3 id="牛生小牛的问题"><a href="#牛生小牛的问题" class="headerlink" title="牛生小牛的问题"></a>牛生小牛的问题</h3><p>传说中300分的题目，题目具体数据记不清了，是牛生小牛的问题，不过好像和经典例题的递归形式不同，这题我在思考的时候加上了dp的思想，<del>因为用递归模拟，发现过不了样例</del>，代码如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 读取第一行的n</span></span><br><span class="line">    n = <span class="built_in">int</span>(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 每一个例子</span></span><br><span class="line">        M = eval(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line">        N = eval(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line">        cheng=[M,M,M,M,M]</span><br><span class="line">        wei=[<span class="number">0</span>,M,<span class="number">2</span>*M,<span class="number">3</span>*M,<span class="number">4</span>*M]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,N+<span class="number">1</span>):</span><br><span class="line">            cheng.append(cheng[i-<span class="number">1</span>]+(wei[i-<span class="number">3</span>]-wei[i-<span class="number">4</span>]))</span><br><span class="line">            wei.append(wei[i-<span class="number">1</span>]+cheng[i]-(wei[i-<span class="number">3</span>]-wei[i-<span class="number">4</span>]))</span><br><span class="line">            <span class="comment"># print(i,cheng[i],wei[i])</span></span><br><span class="line">        print(cheng[N]+wei[N])</span><br></pre></td></tr></table></figure></p><p>就这样三道题目就全部AC了，难度不是太大，感觉打过ACM的全AC是很正常的事情，所以对ACMer菊厂也是相当欢迎的。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>九月初拿到学校保研资格的那天，放弃了菊厂的面试，菊厂打了好几个电话来问，给人的感觉是相当负责的，当时和他们说等我研究生毕业再去菊厂了，哈哈哈，又装了13，溜了溜了看书了。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python实践——塔防游戏</title>
      <link href="/2018/07/20/python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/07/20/python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这仅仅只是一个入门级游戏，一个小toy，使用的也就是贴图形式的pygame，因为需要过多的访存次数，图片的精度也较高，所以对内存以及硬盘的速度有着较高的要求。<del>当时答辩的辣鸡主机上，我们跑的就相当卡。</del></p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>语言版本：python 3.6.2<br><br>依赖：pygame<br><br>系统：皆可<br></p><h2 id="游戏按键"><a href="#游戏按键" class="headerlink" title="游戏按键"></a>游戏按键</h2><p>暂停/开始：Space<br><br>退出：Esc<br></p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="/2018/07/20/python实践——塔防游戏/开始界面.png" alt="游戏开成动画" title="游戏开成动画"><br><img src="/2018/07/20/python实践——塔防游戏/游戏截图.png" alt="游戏中截图" title="游戏截图"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><a href="https://github.com/netycc/Tower-defense-game" title="塔防游戏" target="_blank" rel="noopener">https://github.com/netycc/Tower-defense-game</a></p>]]></content>
      
      
      <categories>
          
          <category> 课设记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

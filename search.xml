<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TensorFlow学习手册（二）</title>
      <link href="/2018/11/10/TensorFlow%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/11/10/TensorFlow%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎来到我的博客，由于一些原因，请输入密码查看。" />    <label for="pass">欢迎来到我的博客，由于一些原因，请输入密码查看。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow学习手册（一）</title>
      <link href="/2018/11/09/TensorFlow%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/11/09/TensorFlow%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;从老师那里得知，未来我们使用的比较多的都是深度学习，因此想要系统地学习一下TensorFlow的使用，之前都是半半拉拉的初学而已。</p><h2 id="TensorFlow入门"><a href="#TensorFlow入门" class="headerlink" title="TensorFlow入门"></a>TensorFlow入门</h2><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p>&emsp;&emsp;在TensorFlow中，张量可以被简单地理解为多维数组。其中零阶张量可以理解为标量，也就是一个数；第一阶张量为向量，也就是一个一维数组；第n阶张量可以理解为一个n维数组。TensorFlow中张量中没有真正的保存数字，它保存的是如何得到这些数字的计算过程，<strong>获得是对结果的一个引用</strong>。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>&emsp;&emsp;在TensorFlow中，是使用会话（session）来执行定义好的运算。会话拥有并管理TensorFlow程序运行时的所有资源。所有计算完成之后需要关闭会话来帮助系统回收资源，<strong>否则可能出现资源泄露</strong>。<br>&emsp;&emsp;可以使用python的上下文管理器来使用会话。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.<span class="built_in">run</span>()</span><br><span class="line"><span class="comment"># 不需要调用"session.close()"函数关闭会话</span></span><br><span class="line"><span class="comment"># 当上下文退出时会话关闭和资源释放叶自动完成了</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;TensorFlow中会有着这样的机制，它不会自动生成默认的会话，而是手动指定。当默认的会话被指定之后可以通过tf.Tensor.eval函数来计算一个张量的取值。以下代码展示了通过设定默认会话计算张量的取值。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sess</span>=tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两个命令有着相同的功能</span></span><br><span class="line"><span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(result))</span><br><span class="line"><span class="builtin-name">print</span>(result.eval(<span class="attribute">session</span>=sess))</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;TensorFlow提供了一种在交互式环境下直接构建默认会话的函数。这个函数就是tf.InteractiveSession。使用这个函数会自动将生成的会话注册为默认会话。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sess</span>=tf.InteractiveSession()</span><br><span class="line"><span class="builtin-name">print</span>(result.eval())</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;并且也可以通过ConfigProto Protocol Buffer来配置需要生成的会话，下面给出了通过ConfigProto配置会话的方法；<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config</span> = tf.ConfigProto(allow_soft_placement=<span class="literal">True</span>,log_device_placement=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">sess1</span>=tf.InteractiveSession(config=config)</span><br><span class="line"><span class="attr">sess2</span>=tf.Session(config=config)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过ConfigProto可以配置类似并行的线程数、GPU分配策略、运算超时时间等参数，在这些参数中，最常用的有两个。第一个是allow_soft_placement，这是一个布尔型的参数，当它为True时，在以下任意一个条件成立时，GPU上的运算可以放到CPU上进行：</p><ol><li>运算无法在GPU上执行。</li><li>没有GPU资源（比如运算被放在第二个GPU上运行，但是机器上只有一个GPU）</li><li>运算输入包含对CPU计算结果的引用</li></ol><p>&emsp;&emsp;这个参数一般默认为False，但是为了使得代码的可移植性更强，在有GPU的环境下，这个参数一般会被设置为True。<br>&emsp;&emsp;第二个使用的比较多的配置参数是log_device_placement。这也是一个布尔型的参数，当它为True是日志中会详细记录以方便调试。而在生产环境中将该参数设置为Flase可以减少日志量。</p><h2 id="前向传播算法介绍"><a href="#前向传播算法介绍" class="headerlink" title="前向传播算法介绍"></a>前向传播算法介绍</h2><p><img src="/2018/11/09/TensorFlow学习手册（一）/QQ20181109-203545.png" alt="神经网络前向传播算法示意图"></p><p>&emsp;&emsp;前向传播算法通过矩阵乘法的方式表达。在TensorFlow中矩阵乘法是非常容易实现的。以下TensorFlow程序实现了如图所示的前向传播算法过程。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = tf.matmul(x,w1)</span><br><span class="line"><span class="attr">y</span> = tf.matmul(a,w2)</span><br></pre></td></tr></table></figure></p><h2 id="TensorFlow变量"><a href="#TensorFlow变量" class="headerlink" title="TensorFlow变量"></a>TensorFlow变量</h2><p>&emsp;&emsp;在TensorFlow中变量(tf.Variable)的作用就是保存和更新神经网络中的参数。变量一定是要初始化的，一般使用随机数给变量进行初始化，下面一段代码就是声明一个$2\times3$的矩阵变量的方法：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 产生<span class="number">2</span>*<span class="number">3</span>的矩阵，矩阵中的元素是均值为<span class="number">0</span>，标准差为<span class="number">2</span>的随机数。</span><br><span class="line">weights = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段代码调用了TensorFlow变量的声明函数tf.Variable。在变量声明函数中给出了初始化这个变量的方法。<code>tf.random_normal</code>函数是通过参数<code>mean</code>来指定平均值，当没有指定的时候默认为0。下表为Tensorflow支持的部分随机数生成函数<strong>（随机数生成函数）</strong>。</p><table><thead><tr><th>函数名称</th><th>随机数分布</th><th>主要参数</th></tr></thead><tbody><tr><td>tf.random_normal</td><td>正态分布</td><td>平均值、标准差、取值类型</td></tr><tr><td>tf.truncated_normal</td><td>正态分布，但如果随机出来的值偏离平均值超过2个标准差，那么这个数将会被重新随机</td><td>平均值、标准差、取值类型</td></tr><tr><td>tf.random_uniform</td><td>均匀分布</td><td>最小、最大取值、取值类型</td></tr><tr><td>tf.random_gamma</td><td>Gamma分布</td><td>形状参数alpha、尺度参数beta、取值类型</td></tr></tbody></table><p>&emsp;&emsp;TensorFlow也支持通过常数来初始化一个变量。下表给出了TensorFlow中常用的变量声明方法<strong>（常数生成函数）</strong>。</p><table><thead><tr><th>函数名称</th><th>功能</th><th>样例</th></tr></thead><tbody><tr><td>tf.zeros</td><td>产生全0的数组</td><td>tf.zeros([2,3],int32)-&gt;[[0,0,0][0,0,0]]</td></tr><tr><td>tf.ones</td><td>产生全1的数组</td><td>tf.ones([2,3],int32)-&gt;[[1,1,1][1,1,1]]</td></tr><tr><td>tf.fill</td><td>产生全固定数字的数组</td><td>tf.fill([2,3],9)-&gt;[[9,9,9][9,9,9]]</td></tr><tr><td>tf.constant</td><td>产生一个给定值的常量</td><td>tf.constant([1,2,3])-&gt;[1,2,3]</td></tr></tbody></table><p>&emsp;&emsp;虽然直接调用每个变量的初始化过程是一个可行的方案，但是当变量增多，或者变量之间存在依赖关系，单个调用的方案就比较麻烦了。为了解决这个问题，TensorFlow提供了一种更加便捷的方式来完成变量初始化过程。通过<code>tf.global_variables_initalizer</code>函数实现初始化所有变量的过程：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line">sess.run(init_op)</span><br></pre></td></tr></table></figure></p><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>&emsp;&emsp;反向传播算法实现了一个迭代的过程。在每次迭代的开始首先需要选取一小部分训练数据，这一小部分数据叫做一个batch。然后，这个batch的样例会通过前向传播算法得到神经网络模型的预测结果。因为训练数据都有数据标注，所以可以计算出当前神经网络模型的预测答案和标准答案之间的差距(LOSS)，最后，基于loss反向传播算法会相应更新神经网络参数的取值，使得在这个batch上神经网络模型的预测结果和真实答案更加接近。</p><p>&emsp;&emsp;为了避免数据过大而导致的计算图过大，TensorFlow提供了placeholder机制用于提供输入数据。placeholder相当于定义了一个位置，这个位置中的数据在程序运行时再指定。在placeholder定义时，这个位置上的数据类型是需要指定的。和其他张量一样，placeholder的类型是不可改变的。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32,shape=(None, 2),<span class="attribute">name</span>=<span class="string">"input"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(y,feed_dict=&#123;x:[ [] , [] , [] ]&#125;))</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在得到一个batch的前向传播结果之后，需要定义一个损失函数来刻画当前的预测值和真实答案之间的差距。然后通过反向传播算法来调整神经网络参数的取值使得差距可以被缩小。以下代码定义了一个简单的损失函数，并通过TensorFlow定义了反向传播的算法：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sigmoid函数使y转化为0~1之间的概率，y为预测是正样本的概率</span></span><br><span class="line">y = tf.sigmoid(y)</span><br><span class="line"><span class="comment"># 定义损失函数来刻画预测值与真实值之间的差距</span></span><br><span class="line">cross_entropy = -tf.reduce_mean(y_*tf.log(tf.clip_by_value(y,1e-10,1.0)),</span><br><span class="line">                                    +(1-y)*tf.log(tf.clip_by_value(1-y,1e-10,1.0)))</span><br><span class="line"><span class="comment"># 定义学习率</span></span><br><span class="line">learning_rate = 0.001</span><br><span class="line"><span class="comment"># 定义反向传播算法来优化神经网络中的参数</span></span><br><span class="line">train_step=tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在以上代码中，cross_entropy定义了真实值和预测值之间的交叉熵，这是分类问题中的一个损失函数。第二行train_step定义了反向传播的优化方法。常用的优化方法有三种：</p><ol><li><code>tf.train.GradientDescentOptimizer</code></li><li><code>tf.train.AdamOptimizer</code></li><li><code>tf.train.MomentumOptimizer</code></li></ol><p>&emsp;&emsp;在定义了反向传播算法之后，通过运行sess.run(train_step)就可以对所有在<code>GraphKeys.TRAINABLE_VARIABLES</code>集合中的变量进行优化，使得在当前batch下损失函数更小。</p><h2 id="神经网络样例程序"><a href="#神经网络样例程序" class="headerlink" title="神经网络样例程序"></a>神经网络样例程序</h2><p>&emsp;&emsp;最后，叙述一下训练神经网络的三个步骤：</p><ol><li>定义神经网络的结构和前向传输的输出结果</li><li>定义损失函数以及选择反向传播优化的算法</li><li>声称会话并且在训练数据上反复运行反向传播优化算法</li></ol><p>&emsp;&emsp;这里列出我们的样例程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Numpy是一个科学计算的工具包，可以通过NumPy工具包生成模拟数据集</span></span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> RandomState</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练数据batch的大小</span></span><br><span class="line">batch_size = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络的参数，这里还是沿用3.4.2小节中给出的神经网络结构</span></span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>),name=<span class="string">"w1"</span>)</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>),name=<span class="string">"w2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">#在shape的一个维度上使用None可以方便使用不同的batch大小。在训练时需要把数据分成比较小的</span></span><br><span class="line"><span class="string">batch，但是在测试时，可以一次性使用全部数据，当数据集比较小的时候这样也比较方便，</span></span><br><span class="line"><span class="string">但是当数据集比较大的时候，将大量的数据放入一个batch可能会导致内存溢出。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">x = tf.placeholder(tf.float32,shape=(<span class="keyword">None</span>,<span class="number">2</span>),name=<span class="string">'x-input'</span>)</span><br><span class="line">y_ = tf.placeholder(tf.float32,shape=(<span class="keyword">None</span>,<span class="number">1</span>),name=<span class="string">'y-input'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络前向传播的过程</span></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和反向传播算法的过程。</span></span><br><span class="line">y = tf.sigmoid(y)</span><br><span class="line">cross_entropy = -tf.reduce_mean(</span><br><span class="line">    y_*tf.log(tf.clip_by_value(<span class="number">1</span>-y,<span class="number">1e-10</span>,<span class="number">1.0</span>))</span><br><span class="line">             +(<span class="number">1</span>-y)*tf.log(tf.clip_by_value(<span class="number">1</span>-y,<span class="number">1e-10</span>,<span class="number">1.0</span>)))</span><br><span class="line">train_step = tf.train.AdamOptimizer(<span class="number">0.001</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过随机数生成一个模拟数据集</span></span><br><span class="line">rdm = RandomState(<span class="number">1</span>)</span><br><span class="line">dataset_size = <span class="number">6400</span></span><br><span class="line">X = rdm.rand(dataset_size,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义规则来给出样本的标签，在这里所有x1+x2&lt;1的样例都被认为是正样本（比如零件合格），</span></span><br><span class="line"><span class="comment"># 而其他为负样本（比如零件不合格）。0表示负样本，1表示正样本</span></span><br><span class="line">Y = [[int(x1+x2&lt;<span class="number">1</span>)] <span class="keyword">for</span> (x1,x2) <span class="keyword">in</span> X]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个回话来运行TensorFlow程序</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op=tf.global_variables_initializer()</span><br><span class="line">    <span class="comment">#初始化变量</span></span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"After w1:\n"</span>,sess.run(w1))</span><br><span class="line">    print(<span class="string">"After w2:\n"</span>,sess.run(w2))</span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设定训练的轮数</span></span><br><span class="line">    STEPS=<span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        <span class="comment"># 每次选取batch_size个体样本进行训练</span></span><br><span class="line">        start = (i*batch_size) % dataset_size</span><br><span class="line">        end = min(start+batch_size,dataset_size)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#通过选取的样本训练神经网络并更新参数</span></span><br><span class="line">        sess.run(train_step,</span><br><span class="line">                feed_dict=&#123;x:X[start:end],y_:Y[start:end]&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#每隔一段时间计算在所有数据上的交叉熵并输出</span></span><br><span class="line">            total_cross_entropy = sess.run(</span><br><span class="line">                cross_entropy,feed_dict=&#123;x:X,y_:Y&#125;)</span><br><span class="line">            print(<span class="string">"After %d training step(s),cross entropy on all data is %g"</span> %</span><br><span class="line">                 (i,total_cross_entropy))</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">80</span>)</span><br><span class="line">    print(<span class="string">"final w1: \n"</span>,sess.run(w1))</span><br><span class="line">    print(<span class="string">"final w2: \n"</span>,sess.run(w2))</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/09/TensorFlow学习手册（一）/QQ20181109-184739.png" alt="运行输出"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu16.04显卡驱动安装及环境配置</title>
      <link href="/2018/10/31/ubuntu16-04%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/10/31/ubuntu16-04%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在新的Ubuntu电脑上进行环境配置，由于系统不是自己弄的，因此也不知道工作人员弄了什么情况的系统，所以持续排坑，装环境。</p><h2 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h2><p>这一步是基础步骤，为了能够远程访问该计算机。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install openssh-server</span><br><span class="line">sudo<span class="built_in"> service </span>ssh restart</span><br></pre></td></tr></table></figure></p><h2 id="安装Anaconda3"><a href="#安装Anaconda3" class="headerlink" title="安装Anaconda3"></a>安装Anaconda3</h2><p>从清华源中获得Anaconda3的<strong>5.2.0版本</strong>，因为5.3.0版本是基于python3.7的，暂时没有tensorflow等库的适配。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bash</span> <span class="selector-tag">Anaconda3-5</span><span class="selector-class">.2</span><span class="selector-class">.0-Linux-x86_64</span><span class="selector-class">.sh</span></span><br><span class="line"># 注意，需要同意它写入<span class="selector-tag">path</span>中去，然后更新环境变量</span><br><span class="line"><span class="selector-tag">source</span> <span class="selector-class">.bashrc</span></span><br></pre></td></tr></table></figure></p><h2 id="更换python源"><a href="#更换python源" class="headerlink" title="更换python源"></a>更换python源</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.pip</span><br><span class="line"><span class="keyword">vim</span> ~/.pip/pip.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>在pip.conf中添加如下内容：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">trusted-host = pypi<span class="selector-class">.tuna</span><span class="selector-class">.tsinghua</span><span class="selector-class">.edu</span><span class="selector-class">.cn</span></span><br></pre></td></tr></table></figure></p><h2 id="卸载原生显卡驱动"><a href="#卸载原生显卡驱动" class="headerlink" title="卸载原生显卡驱动"></a>卸载原生显卡驱动</h2><p>因为系统中本身的显卡驱动是工作人员双击安装的app，因此版本很老，并且不适配cuda，因此我们需要重新安装。<br>卸载NVIDIA驱动<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> --purge nvidia-*</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> autoremove</span><br></pre></td></tr></table></figure></p><h2 id="安装官网新的驱动"><a href="#安装官网新的驱动" class="headerlink" title="安装官网新的驱动"></a>安装官网新的驱动</h2><p>先说一下，我们需要的几个软件包，NVIDIA驱动、<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">cuda8.0</a>，都可以在官网在下载到。</p><ol><li><p>修改/etc/modprobe.d/blacklist.conf，添加如下内容：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blacklist </span>vag16fb</span><br><span class="line"><span class="keyword">blacklist </span>nouveau  </span><br><span class="line"><span class="keyword">blacklist </span>rivafb</span><br><span class="line"><span class="keyword">blacklist </span>rivatv</span><br><span class="line"><span class="keyword">blacklist </span>nvidiafb</span><br></pre></td></tr></table></figure></li><li><p>新建blacklist-nouveau.conf文件，sudo nano /etc/modprobe.d/blacklist-nouveau.conf,并在文件中输入命令，保存并退出。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blacklist </span>nouveau</span><br><span class="line"><span class="keyword">blacklist </span><span class="keyword">lbm-nouveau</span></span><br><span class="line"><span class="keyword">options </span>nouveau modeset=<span class="number">0</span></span><br><span class="line">alias nouveau off</span><br><span class="line">alias <span class="keyword">lbm-nouveau </span>off</span><br></pre></td></tr></table></figure></li><li><p>更新内核及配置文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo update-initramfs -u</span></span><br><span class="line"><span class="attribute">sudo reboot</span></span><br></pre></td></tr></table></figure></li><li><p>重新安装NVIDIA驱动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>lightdm stop</span><br><span class="line">sudo sh ./NVIDIA-Linux-x86_64-xxx.<span class="builtin-name">run</span> --no-opengl-files</span><br><span class="line">(sudo sh ./NVIDIA.<span class="builtin-name">run</span> -no-x-check -no-nouveau-check -no-opengl-files这句也可以不用)</span><br><span class="line">sudo<span class="built_in"> service </span>lightdm start</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo reboot</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装cuda</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bash</span> <span class="selector-tag">cuda_8</span><span class="selector-class">.0</span><span class="selector-class">.61_375</span><span class="selector-class">.26_linux</span><span class="selector-class">.run</span></span><br></pre></td></tr></table></figure><h2 id="安装TensorFlow-gpu版本"><a href="#安装TensorFlow-gpu版本" class="headerlink" title="安装TensorFlow-gpu版本"></a>安装TensorFlow-gpu版本</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> tensorflow-gpu</span><br></pre></td></tr></table></figure><p>我遇到了权限问题，可以用以下语句解决：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R <span class="string">[username]</span>:<span class="string">[username]</span> /home/<span class="string">[username]</span>/anaconda3</span><br></pre></td></tr></table></figure></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>最后配置就完成了，以下为本人参考博客：</p><ol><li><a href="https://blog.csdn.net/gaowu959/article/details/79596724" target="_blank" rel="noopener">Ubuntu16.04+1080ti显卡驱动安装流程+循环登录问题【集锦】</a></li><li><a href="https://blog.csdn.net/u013000139/article/details/72991881" target="_blank" rel="noopener">NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the lat</a></li><li><a href="https://blog.csdn.net/jizhidexiaoming/article/details/79526123" target="_blank" rel="noopener">Ubuntu16.04安装tensorflow_gpu教程</a></li><li><a href="https://blog.csdn.net/Guangli_R/article/details/80859479" target="_blank" rel="noopener">ubuntu conda 更新、下载模块包权限问题 ‘Permission denied’</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 显卡驱动配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>隐马尔可夫模型及分词上的实现</title>
      <link href="/2018/10/28/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%88%86%E8%AF%8D%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/28/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%88%86%E8%AF%8D%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始看自然语言处理的实战部分，看到了<strong>统计分词</strong>那里，统计分词用的模型是<strong>隐马尔可夫模型</strong>(HMM)，这里先介绍一下这个模型，它是可用于标注问题的统计学模型，描述由隐藏的马尔可夫链随机生成观测序列的过程，属于<strong>生成模型</strong>。</p><h2 id="隐马尔可夫模型的基本概念"><a href="#隐马尔可夫模型的基本概念" class="headerlink" title="隐马尔可夫模型的基本概念"></a>隐马尔可夫模型的基本概念</h2><h3 id="隐马尔可夫模型的定义"><a href="#隐马尔可夫模型的定义" class="headerlink" title="隐马尔可夫模型的定义"></a>隐马尔可夫模型的定义</h3><blockquote><p>定义10.1(隐马尔可夫模型)<br>隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列，称为<strong>状态序列</strong>；每个状态生成一个观测，而由此产生的观测的随机序列，称为<strong>观测序列</strong>。序列的每一个位置又可以看作是一个时刻。</p></blockquote><p>隐马尔可夫模型由初始概率分布、状态转移概率分布以及观测概率分布确定。隐马尔可夫模型的形式定义如下：<br>设$Q$是所有可能的状态的集合，$V$是所有可能的观测的集合。$$Q=\{q_1,q_2,…,q_N\}，V=\{v_1,v_2,…,v_M\}$$其中，$N$是可能的状态数，$M$是可能的观测数.以下$I$是长度为$T$的状态序列，$O$是对应的观测序列。$$I=(i_1,i_2,…,i_T)，O=(o_1,o_2,…,o_T)$$$A$是状态转移概率矩阵.$$A=[a_{ij}]_{N\times N}\tag{10.1}$$</p><p>其中，$$a_{ij}=P(i_{t+1}=q_j|i_t=q_i)，i=1,2,…,N;j=1,2,…,N\tag{10.2}$$是在时刻t处于$q_i$的条件下在时刻$t+1$转移到状态$q_j$的概率。<br>$B$是观测概率矩阵：$$B=[b_j(k)]_{N\times M}\tag{10.3}$$其中，$$b_j(k)=P(o_t=v_k|i_t=q_j)，k=1,2,…,M;j=1,2,…,N\tag{10.4}$$是在时刻$t$处于状态$q_j$的条件下生成观测$v_k$的概率。<br>$\pi$是初始状态概率向量：$$\pi=(\pi_i)\tag{10.5}$$其中，$$\pi_i=P(i_1=q_i)，i=1,2,…,N\tag{10.6}$$是时刻$t=1$处于状态$q_i$的概率。<br>隐马尔可夫模型由初始状态概率向量$\pi$、状态转移概率矩阵$A$和观测概率矩阵$B$决定。$\pi$和$A$决定状态序列，$B$决定观测序列。因此，隐马尔可夫模型$\lambda$可以用三元符号表示，即$$\lambda=(A,B,\pi)\tag{10.7}$$<br>$A,B,\pi$称为隐马尔可夫模型的三要素。<br>状态转移概率矩阵$A$与初始状态概率向量$\pi$确定了隐藏的马尔可夫链，生成不可观测的状态序列。观测概率矩阵$B$确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列。<br>从定义上可知，隐马尔可夫模型作了两个基本假设：</p><ol><li>齐次马尔可夫性假设，即假设隐藏的马尔可夫链在任意时刻$t$的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻$t$无关。$$P(i_t|i_{t-1},o_{t-1},…,i_1,o_1)=P(i_t|i_{t-1})，t=1,2,…,T\tag{10.8}$$</li><li>观测独立性假设，即假设任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关。$$P(o_t|i_T,o_T,i_{T-1},o_{T-1},…,i_{t+1},o_{t+1},i_t,i_{t-1},o_{t-1},…,i_1,o_1)=P(o_t|i_t)\tag{10.9}$$</li></ol><p>&emsp;&emsp;隐马尔可夫模型可以用于标注，这时状态对应着标记。标注问题是给定观测的序列预测其对应的标记序列。可以假设标注问题的数据是由隐马尔可夫模型生成的。这样我们可以利用隐马尔可夫模型的学习与预测算法进行标注。</p><h3 id="观测序列的生成过程"><a href="#观测序列的生成过程" class="headerlink" title="观测序列的生成过程"></a>观测序列的生成过程</h3><p>&emsp;&emsp;根据隐马尔可夫模型定义，可以将一个长度为$T$的观测序列$O=(O_1,O_2,…,O_T)$的生成过程描述如下：</p><blockquote><p>算法10.1（观测序列的生成）<br>输入：隐马尔可夫模型$\lambda=(A,B,\pi)$，观测序列长度为$T$；<br>输出：观测序列$O=(o_1,o_2,…,o_T)$<br>(1)按照初始状态分布$\pi$产生状态$i_1$<br>(2)令$t=1$<br>(3)按照状态$i_t$的观测概率分布$b_{i_t}(k)$生成$o_t$<br>(4)按照状态$i_t$的状态转移概率分布$\{a_{i_ti_{t+1}}\}$产生状态$i_t+1，i_t+1=1,2,…,N$<br>(5)令$t=t+1$；如果$t&lt;T$，转步(3)；否则，终止。</p></blockquote><h3 id="隐马尔可夫模型的3个基本问题"><a href="#隐马尔可夫模型的3个基本问题" class="headerlink" title="隐马尔可夫模型的3个基本问题"></a>隐马尔可夫模型的3个基本问题</h3><p>隐马尔可夫模型有三个基本问题：</p><ol><li>概率计算问题。给定模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算在模型$\lambda$下观测序列$O$出现的概率$P(O|\lambda)$.</li><li>学习问题。已知观测序列$O=(o_1,o_2,…,o_T)$，估计模型$\lambda=(A,B,\pi)$参数，使得在该模型下观测序列概率$P(O|\lambda)$最大。即用极大似然估计的方法估计参数。</li><li>预测问题。已知模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，求对给定观测序列条件概率$P(I|O)$最大的状态序列$I=(i_1,i_2,…,i_T)$。即给定观测序列，求最有可能的对应的状态序列。</li></ol><h2 id="概率计算方法"><a href="#概率计算方法" class="headerlink" title="概率计算方法"></a>概率计算方法</h2><p>&emsp;&emsp;在这一节中，介绍一下计算观测序列概率$P(O|\lambda)$的前向(forward)和后向(backward)算法。先介绍概念上可行但<em>计算上不可行</em>的直接计算法。</p><h3 id="直接计算法"><a href="#直接计算法" class="headerlink" title="直接计算法"></a>直接计算法</h3><p>&emsp;&emsp;给定模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算观测序列$O$出现的概率$P(O|\lambda)$。最直接的方法是按概率公式直接计算。通过列举所有可能的长度为$T$的状态序列$I=(i_1,i_2,…,i_T)$，求各个状态序列I与观测序列$O=(o_1,o_2,…,o_T)$的联合概率$P(O,I|\lambda)$，然后对所有可能的状态序列求和，得到$P(O|\lambda)$.<br>&emsp;&emsp;状态序列$I=(i_1,i_2,…,i_T)$的概率是$$P(I|\lambda)=\pi_{i_1}a_{i_1i_2}a_{i_2i_3}…a_{i_{T-1}i_T}\tag{10.10}$$<br>&emsp;&emsp;对固定的状态序列I=（i_1,i_2,…,i_T)，观测序列$O=(o_1,o_2,…,o_T)$的概率是$P(O|I,\lambda)=b_{i_1}(o_1)b_{i_2}(o_2)…b_{i_T}(o_T)\tag{10.11}$<br>&emsp;&emsp;$O$和$I$同时出现的联合概率为$$P(O|I,\lambda)=P(I|\lambda)=\pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b_{i_T}(O_T)\tag{10.12}$$<br>&emsp;&emsp;然后，对所有可能的状态序列$I$求和，得到观测序列$O$的概率$P(O|\lambda)$，即$$<br>\begin{split}<br>P(O|\lambda)&amp;=\sum_IP(O|I,\lambda)P(I|\lambda)\\<br>&amp;=\sum_{i_1,i_2,…,i_T}{\pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b_{i_T}(O_T)}<br>\end{split}\tag{10.13}<br>$$<br>&emsp;&emsp;但是，利用公式(10.13)计算量很大，是$O(TN^T)$阶的，这种算法不可行。</p><h3 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h3><p>&emsp;&emsp;首先定义前向概率</p><blockquote><p>定义10.2（前向概率）&emsp;给定隐马尔可夫模型$\lambda$，定义到时刻$t$部分观测序列为$o_1,o_2,…,o_t$且状态为$q_i$的概率为前向概率，记作$$\alpha _t(i)=P(o_1,o_2,…,o_t,i_t=q_i|\lambda)\tag{10.14}$$</p></blockquote><p>&emsp;&emsp;可以递推地求得前向概率$\alpha_t(i)$及观测序列概率$P(O|\lambda)$。</p><blockquote><p>算法10.2（观测序列概率的前向算法）<br>输入：隐马尔可夫模型$\lambda$，观测序列$O$;<br>输出：观测序列概率$P(O|\lambda)$.</p><ol><li>初值$$\alpha_1(i)=\pi_ib_i(o_1),i=1,2,…,N\tag{10.15}$$</li><li>递推&emsp;对$t=1,2,…,T-1$.$$\alpha_{t+1}(i)=[\sum_{j=1}^{N}\alpha_t(j)a_{ji}]b_i(o_t+1),i=1,2,…,N\tag{10.16}$$</li><li>终止$$P(O|\lambda)=\sum_{i=1}^{N}\alpha_T(i)\tag{10.17}$$</li></ol></blockquote><p><img src="/2018/10/28/隐马尔可夫模型及分词上的实现/QQ20181105-211743.png" alt="图 10.1 前向概率的递推公式"><br><img src="/2018/10/28/隐马尔可夫模型及分词上的实现/QQ20181105-213913.png" alt="图 10.2 观测序列路径结构"></p><blockquote><p>未完待续</p></blockquote><h2 id="HMM在统计分词中的实现"><a href="#HMM在统计分词中的实现" class="headerlink" title="HMM在统计分词中的实现"></a>HMM在统计分词中的实现</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">class HMM(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        import os</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主要是用于存取算法中间结果，不用每次都训练模型</span></span><br><span class="line">        self.model_file = './data/hmm_model.pkl'</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态值集合</span></span><br><span class="line">        self.state_list = ['B', 'M', 'E', 'S']</span><br><span class="line">        <span class="comment"># 参数加载,用于判断是否需要重新加载model_file</span></span><br><span class="line">        self.load_para = False</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于加载已计算的中间结果，当需要重新训练时，需初始化清空结果</span></span><br><span class="line">    def try_load_model(self, trained):</span><br><span class="line">        if trained:</span><br><span class="line">            import pickle</span><br><span class="line">            <span class="keyword">with</span> <span class="keyword">open</span>(self.model_file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                self.A_dic = pickle.load(f)</span><br><span class="line">                self.B_dic = pickle.load(f)</span><br><span class="line">                self.Pi_dic = pickle.load(f)</span><br><span class="line">                self.load_para = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 状态转移概率（状态-&gt;状态的条件概率）</span></span><br><span class="line">            self.A_dic = &#123;&#125;</span><br><span class="line">            <span class="comment"># 发射概率（状态-&gt;词语的条件概率）</span></span><br><span class="line">            self.B_dic = &#123;&#125;</span><br><span class="line">            <span class="comment"># 状态的初始概率</span></span><br><span class="line">            self.Pi_dic = &#123;&#125;</span><br><span class="line">            self.load_para = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算转移概率、发射概率以及初始概率</span></span><br><span class="line">    <span class="keyword">def</span> train(<span class="keyword">self</span>, <span class="keyword">path</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重置几个概率矩阵</span></span><br><span class="line">        self.try_load_model(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计状态出现次数，求p(o)</span></span><br><span class="line">        Count_dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化参数</span></span><br><span class="line">        <span class="keyword">def</span> init_parameters():</span><br><span class="line">            <span class="keyword">for</span> state <span class="keyword">in</span> self.state_list:</span><br><span class="line">                self.A_dic[state] = &#123;s: <span class="number">0.0</span> <span class="keyword">for</span> s <span class="keyword">in</span> self.state_list&#125;</span><br><span class="line">                self.Pi_dic[state] = <span class="number">0.0</span></span><br><span class="line">                self.B_dic[state] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">                Count_dic[state] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> makeLabel(<span class="built_in">text</span>):</span><br><span class="line">            out_text = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">len</span>(<span class="built_in">text</span>) == <span class="number">1</span>:</span><br><span class="line">                out_text.append(<span class="string">'S'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                out_text += [<span class="string">'B'</span>] + [<span class="string">'M'</span>] * (<span class="keyword">len</span>(<span class="built_in">text</span>) - <span class="number">2</span>) + [<span class="string">'E'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> out_text</span><br><span class="line"></span><br><span class="line">        init_parameters()</span><br><span class="line">        line_num = <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 观察者集合，主要是字以及标点等</span></span><br><span class="line">        words = <span class="keyword">set</span>()</span><br><span class="line">        <span class="keyword">with</span> <span class="keyword">open</span>(<span class="keyword">path</span>, <span class="keyword">encoding</span>=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                line_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                line = line.strip()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    continue</span><br><span class="line"></span><br><span class="line">                word_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> line <span class="keyword">if</span> i != <span class="string">' '</span>]</span><br><span class="line">                words |= <span class="keyword">set</span>(word_list)  <span class="comment"># 更新字的集合</span></span><br><span class="line"></span><br><span class="line">                linelist = line.split()</span><br><span class="line"></span><br><span class="line">                line_state = []</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> linelist:</span><br><span class="line">                    line_state.extend(makeLabel(w))</span><br><span class="line"></span><br><span class="line">                assert <span class="keyword">len</span>(word_list) == <span class="keyword">len</span>(line_state)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(line_state):</span><br><span class="line">                    Count_dic[v] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                        self.Pi_dic[v] += <span class="number">1</span>  <span class="comment"># 每个句子的第一个字的状态，用于计算初始状态概率</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.A_dic[line_state[k - <span class="number">1</span>]][v] += <span class="number">1</span>  <span class="comment"># 计算转移概率</span></span><br><span class="line">                        self.B_dic[line_state[k]][word_list[k]] = \</span><br><span class="line">                            self.B_dic[line_state[k]].get(word_list[k], <span class="number">0</span>) + <span class="number">1.0</span>  <span class="comment"># 计算发射概率</span></span><br><span class="line"></span><br><span class="line">        self.Pi_dic = &#123;k: v * <span class="number">1.0</span> / line_num <span class="keyword">for</span> k, v <span class="keyword">in</span> self.Pi_dic.items()&#125;</span><br><span class="line">        self.A_dic = &#123;k: &#123;k1: v1 / Count_dic[k] <span class="keyword">for</span> k1, v1 <span class="keyword">in</span> v.items()&#125;</span><br><span class="line">                      <span class="keyword">for</span> k, v <span class="keyword">in</span> self.A_dic.items()&#125;</span><br><span class="line">        <span class="comment"># 加1平滑</span></span><br><span class="line">        self.B_dic = &#123;k: &#123;k1: (v1 + <span class="number">1</span>) / Count_dic[k] <span class="keyword">for</span> k1, v1 <span class="keyword">in</span> v.items()&#125;</span><br><span class="line">                      <span class="keyword">for</span> k, v <span class="keyword">in</span> self.B_dic.items()&#125;</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        <span class="keyword">import</span> pickle</span><br><span class="line">        <span class="keyword">with</span> <span class="keyword">open</span>(self.model_file, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            pickle.dump(self.A_dic, f)</span><br><span class="line">            pickle.dump(self.B_dic, f)</span><br><span class="line">            pickle.dump(self.Pi_dic, f)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> viterbi(<span class="keyword">self</span>, <span class="built_in">text</span>, states, start_p, trans_p, emit_p):</span><br><span class="line">        V = [&#123;&#125;]</span><br><span class="line">        <span class="keyword">path</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> states:</span><br><span class="line">            V[<span class="number">0</span>][y] = start_p[y] * emit_p[y].get(<span class="built_in">text</span>[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">path</span>[y] = [y]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, <span class="keyword">len</span>(<span class="built_in">text</span>)):</span><br><span class="line">            V.append(&#123;&#125;)</span><br><span class="line">            newpath = &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检验训练的发射概率矩阵中是否有该字</span></span><br><span class="line">            neverSeen = <span class="built_in">text</span>[t] <span class="keyword">not</span> <span class="keyword">in</span> emit_p[<span class="string">'S'</span>].keys() <span class="keyword">and</span> \</span><br><span class="line">                        <span class="built_in">text</span>[t] <span class="keyword">not</span> <span class="keyword">in</span> emit_p[<span class="string">'M'</span>].keys() <span class="keyword">and</span> \</span><br><span class="line">                        <span class="built_in">text</span>[t] <span class="keyword">not</span> <span class="keyword">in</span> emit_p[<span class="string">'E'</span>].keys() <span class="keyword">and</span> \</span><br><span class="line">                        <span class="built_in">text</span>[t] <span class="keyword">not</span> <span class="keyword">in</span> emit_p[<span class="string">'B'</span>].keys()</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> states:</span><br><span class="line">                emitP = emit_p[y].get(<span class="built_in">text</span>[t], <span class="number">0</span>) <span class="keyword">if</span> <span class="keyword">not</span> neverSeen <span class="keyword">else</span> <span class="number">1.0</span>  <span class="comment"># 设置未知字单独成词</span></span><br><span class="line">                (prob, state) = <span class="keyword">max</span>(</span><br><span class="line">                    [(V[t - <span class="number">1</span>][y0] * trans_p[y0].get(y, <span class="number">0</span>) *</span><br><span class="line">                      emitP, y0)</span><br><span class="line">                     <span class="keyword">for</span> y0 <span class="keyword">in</span> states <span class="keyword">if</span> V[t - <span class="number">1</span>][y0] &gt; <span class="number">0</span>])</span><br><span class="line">                V[t][y] = prob</span><br><span class="line">                newpath[y] = <span class="keyword">path</span>[state] + [y]</span><br><span class="line">            <span class="keyword">path</span> = newpath</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> emit_p[<span class="string">'M'</span>].get(<span class="built_in">text</span>[<span class="number">-1</span>], <span class="number">0</span>) &gt; emit_p[<span class="string">'S'</span>].get(<span class="built_in">text</span>[<span class="number">-1</span>], <span class="number">0</span>):</span><br><span class="line">            (prob, state) = <span class="keyword">max</span>([(V[<span class="keyword">len</span>(<span class="built_in">text</span>) - <span class="number">1</span>][y], y) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="string">'E'</span>, <span class="string">'M'</span>)])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            (prob, state) = <span class="keyword">max</span>([(V[<span class="keyword">len</span>(<span class="built_in">text</span>) - <span class="number">1</span>][y], y) <span class="keyword">for</span> y <span class="keyword">in</span> states])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (prob, <span class="keyword">path</span>[state])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> cut(<span class="keyword">self</span>, <span class="built_in">text</span>):</span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.load_para:</span><br><span class="line">            self.try_load_model(os.path.exists(self.model_file))</span><br><span class="line">        prob, pos_list = self.viterbi(<span class="built_in">text</span>, self.state_list, self.Pi_dic, self.A_dic, self.B_dic)</span><br><span class="line">        <span class="keyword">begin</span>, <span class="keyword">next</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, <span class="built_in">char</span> <span class="keyword">in</span> enumerate(<span class="built_in">text</span>):</span><br><span class="line">            pos = pos_list[i]</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="string">'B'</span>:</span><br><span class="line">                <span class="keyword">begin</span> = i</span><br><span class="line">            elif pos == <span class="string">'E'</span>:</span><br><span class="line">                yield <span class="built_in">text</span>[<span class="keyword">begin</span>: i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">next</span> = i + <span class="number">1</span></span><br><span class="line">            elif pos == <span class="string">'S'</span>:</span><br><span class="line">                yield <span class="built_in">char</span></span><br><span class="line">                <span class="keyword">next</span> = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">next</span> &lt; <span class="keyword">len</span>(<span class="built_in">text</span>):</span><br><span class="line">            yield <span class="built_in">text</span>[<span class="keyword">next</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    hmm = HMM()</span><br><span class="line">    hmm.train(<span class="string">'./data/trainCorpus.txt_utf8'</span>)</span><br><span class="line">    <span class="comment"># hmm.try_load_model(True)</span></span><br><span class="line">    <span class="built_in">text</span> = <span class="string">'这是一个非常棒的方案！'</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">text</span> !=<span class="string">'\n'</span>):</span><br><span class="line">        res = hmm.cut(<span class="built_in">text</span>)</span><br><span class="line">        print(<span class="built_in">text</span>)</span><br><span class="line">        print(<span class="keyword">str</span>(<span class="keyword">list</span>(res)))</span><br><span class="line">        <span class="built_in">text</span>=<span class="keyword">input</span>()</span><br></pre></td></tr></table></figure><p><img src="/2018/10/28/隐马尔可夫模型及分词上的实现/QQ20181028-214742.png" alt="分词结果"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学习方法 </tag>
            
            <tag> python </tag>
            
            <tag> NLP </tag>
            
            <tag> HMM </tag>
            
            <tag> CWS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019科大讯飞算法岗校招笔试</title>
      <link href="/2018/10/25/2019%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%AE%97%E6%B3%95%E5%B2%97%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/25/2019%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%AE%97%E6%B3%95%E5%B2%97%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前天收到了科大讯飞算法岗的笔试邀请，因为以后也想从事算法岗的工作，因此试了试水。讯飞在算法岗的笔试题中，有着20题每题三分的选择题，选择题包括了HMM、CRF、生成模型、判别模型等机器学习相关知识，令我以外的是他也包括了很多操作系统相关的算法，比如银行家算法。而后就是两道很简单的编程题，每题二十分。</p><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="修改成绩"><a href="#修改成绩" class="headerlink" title="修改成绩"></a>修改成绩</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p><em>题目描述</em><br>华老师的n个学生参加了一次模拟测验，考出来的分数很糟糕，但是华老师可以将成绩修改为[0,100]中的任意值，所以他想知道，如果要使所有人的成绩的平均分不少于X分，至少要改动多少个人的分数？<br><em>输入</em><br>第一行一个数T，共T组数据（T≤10）<br>接下来对于每组数据：<br>第一行两个整数n和X。（1≤n≤1000, 0≤X≤100）<br>第二行n个整数，第i个数Ai表示第i个学生的成绩。（0≤Ai≤100）<br><em>输出</em><br>共T行，每行一个整数，代表最少的人数。<br><em>样例输入</em><br>2<br>5 60<br>59 20 30 90 100<br>5 60<br>59 20 10 10 100<br><em>样例输出</em><br>1<br>2<br><em>Hint</em><br>对于第一组数据，将59改成60即可</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = <span class="keyword">int</span>(sys.stdin.readline().strip())</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">line</span> = sys.stdin.readline().strip()</span><br><span class="line">        two=<span class="keyword">list</span>(<span class="keyword">map</span>(<span class="keyword">int</span>, <span class="built_in">line</span>.<span class="keyword">split</span>()))</span><br><span class="line">        <span class="built_in">line</span>=sys.stdin.readline().strip()</span><br><span class="line">        n_num=<span class="keyword">list</span>(<span class="keyword">map</span>(<span class="keyword">int</span>, <span class="built_in">line</span>.<span class="keyword">split</span>()))</span><br><span class="line">        mubiao=two[<span class="number">0</span>]*two[<span class="number">1</span>]</span><br><span class="line">        n_num=sorted(n_num)</span><br><span class="line">        flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> sum(n_num)&lt;mubiao <span class="built_in">and</span> flag&lt;=<span class="built_in">len</span>(n_num):</span><br><span class="line">            n_num[flag]=<span class="number">100</span></span><br><span class="line">            flag+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="杀手"><a href="#杀手" class="headerlink" title="杀手"></a>杀手</h3><h4 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h4><p><em>题目描述</em><br>有n个杀手排成一行，每个杀手都有一个不同的编号(编号为1-n)，在每个夜晚，杀手都会行动，如果某个杀手编号大于他右边的杀手的编号，他就会杀死他右边的杀手，杀手是的行动是瞬间的，因此一个人可能某一个夜晚既杀死了别人又被别人杀死，例如3,2,1这个顺序，在第一个夜晚2会杀死1，同时3也会杀死2。<br>显而易见，一段时间之后，就不会有人杀或被杀，平安夜也就到来了，请问在平安夜之前有多少个夜晚。<br><em>输入</em><br>输入第一行是一个整数n（1≤n≤100000）,表示杀手的数量。<br>接下来一行有n个数，是一个1-n的全排列。<br><em>输出</em><br>输出包含一个整数，表示平安夜之前经历了多少个夜晚。<br><em>样例输入</em><br>10 10 9 7 8 6 5 3 4 2 1<br><em>样例输出</em><br>2<br><em>Hint</em><br>补充样例<br>输入样例2： 6 1 2 3 4 5 6<br>输出样例2 ：0<br>样例解释： 样例1中杀手的变化为[10 9 7 8 6 5 3 4 2 1]-&gt;[10 8 4]-&gt;[10]，故答案为2。</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = int(sys.<span class="keyword">stdin</span>.readline().strip())</span><br><span class="line">    <span class="built_in">line</span> = sys.<span class="keyword">stdin</span>.readline().strip()</span><br><span class="line">    <span class="built_in">num</span>=list(map(int, <span class="built_in">line</span>.<span class="built_in">split</span>()))</span><br><span class="line">    flag=True</span><br><span class="line">    cishu=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(flag):</span><br><span class="line">        n=<span class="built_in">len</span>(<span class="built_in">num</span>)</span><br><span class="line">        next=[]</span><br><span class="line">        flag=False</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="built_in">len</span>(<span class="built_in">num</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 发生吃人</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>[n-i]&gt;<span class="built_in">num</span>[n-i+<span class="number">1</span>]):</span><br><span class="line">                flag=True</span><br><span class="line">            <span class="comment"># 吃不掉</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>[n-i]&lt;<span class="built_in">num</span>[n-i+<span class="number">1</span>]):</span><br><span class="line">                next.append(<span class="built_in">num</span>[n-i+<span class="number">1</span>])</span><br><span class="line">                <span class="comment"># flag=True</span></span><br><span class="line">            <span class="comment"># 加入第一个人</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="built_in">len</span>(<span class="built_in">num</span>)):</span><br><span class="line">                next.append(<span class="built_in">num</span>[n-i])</span><br><span class="line">        <span class="built_in">num</span>=list(reversed(next))</span><br><span class="line">        <span class="keyword">if</span>(flag==True):</span><br><span class="line">            cishu+=<span class="number">1</span></span><br><span class="line">    print(cishu)</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不得不说讯飞的速度是挺快的，第二天就发来了面试邀请。但是想问hr招不招实习的时候，hr不回复，因此也就没下文了。面试当然也就没去了，~难受~<br><img src="/2018/10/25/2019科大讯飞算法岗校招笔试/QQ20181026-152734.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>决策树的原理及实现</title>
      <link href="/2018/10/19/%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/19/%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，相对于前面几章，决策树的新鲜知识点明显要多了，引入了很多<em>信息论</em>中的内容，<del>看的很难受呀</del>，不过在信念的坚持下，还是开始总结了本章的知识点。</p><p>决策树是一种基本的分类与回归方法。本篇文章主要讨论分类的决策树，决策树呈现树形结构，在分类问题中，表示基于特征对实例进行分类的过程。它可以被认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。主要优点是<em>模型具有可读型、分类速度快</em>，学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据利用决策树模型进行分类，决策树学习通常包括3个步骤：<em>特征选择、决策树的生成和决策树的修剪</em>。</p><h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><blockquote><p>定义5.1（决策树） 分类决策树模型是一种描述对实例进行分类的树形结构，决策树由结点（node）和有向边（directed edge）组成。结点有两种类型，内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。<br>用决策树分类，从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值，如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。</p></blockquote><h3 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h3><p>可以将决策树看成一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树有着<em>互斥并且完备</em>这一特点。就是说，每一个实例都被一条路径或一条规则所覆盖，并且只被一条路径或一条规则所覆盖。</p><h3 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义。这一条件概率分布定义在特征空间上的一个划分上。将特征空间划分为互不相交的单元或区域，并在每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的一条路径对应于划分中的一个单元，决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。假设X为表示特征的随机变量，Y为表示类的随机变量，那么这个条件概率分布可以表示为P(Y|X)。X取值于给定划分下单元的集合，Y取值于类的集合。各叶结点（单元）上的条件概率往往偏向某一个类，即属于某一类的概率较大。决策树分类时将该结点强行分到条件概率大的那一类去。</p><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习，假设给定训练数据集$$D=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$$其中，$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T$为输入实例（特征向量），$n$为特征个数，$y_i\in \{1,2,…,K\}$为类标记，$i=1,2,…,N$，$N$为样本容量，学习的目标是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。<br>决策树学习本质上是从数据集中归纳出一组分类规则。与训练数据集不相矛盾的决策树可能有多个，也可能一个也没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛华能力。<br>当损失函数确定以后，学习问题就变为在损失函数意义下选择最优决策树的问题。因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树学习算法通常采用<em>启发式</em>方法，近似求解这一最优化问题。这样得到的决策树是次最优的。<br>决策树学习的算法通常是一个递归地选择最优特征，并根据特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。开始，构建根结点，将所有训练数据都放在根结点。选择一个最优特征，按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。如果这些子集已经能够被基本正确分类，那么构建叶结点，并将这些子集分到所对应的叶结点中去；如果还有子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行分割，构建相应的结点。如果递归地进行下去，直至所有训练数据集被基本正确分类，或者没有合适的特征为止，最后每个子集都被分到叶结点上，即都有了明确的类。这就生成了一课决策树。<br>以上方法生成的决策树可能对训练数据集有很好的分类能力，但对未知的测试数据却未必有很好的分类能力，即可能发生<em>过拟合</em>现象。我们需要对已生成的树自下向上而进行剪枝，将树变得更简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="特征选择问题"><a href="#特征选择问题" class="headerlink" title="特征选择问题"></a>特征选择问题</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的准则是<em>信息增益</em>或<em>信息增益比</em>。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>在信息论与概率统计中，熵（entropy）是表示随机变量不确定性的度量。设$X$是一个取有限个值的离散随机变量，其概率分布为$$P(X=x_i)=p_i  ,i=1,2,…,n$$则随机变量$X$的熵定义为$$H(X)=-\sum_{i=1}^{n}{p_i log p_i}$$在式中，若$p_i=0$，则定义$0log0=0$。通常，该式中的对数以2为底或以e为底（自然对数），这时熵的单元分别称作比特或纳特。由定义可知，<em>熵只依赖于X的分布</em>，而与X的取值无关，所以也可将X的熵记作$H(p)$，即$$H(p)=-\sum_{i=1}^{n}p_i log p_i$$</p><p>熵越大，随机变量的不确定性就越大，当$p=0$或$p=1$时$H(p)=0$，随机变量完全没有不确定性。当$p=0.5$时，$H(p)=1$，熵取值就最大，随机变量不确定性最大。</p><p>设有随机变量$(X,Y)$，其联合概率分布为$$P(X=x_i,Y=y_j)=p_{ij}，i=1,2,…,n;j=1,2,…,m$$条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量Y的不确定性。随机变量X给定的条件下随机变量Y的不确定性。随机变量X给定的条件下随机变量Y的条件熵$H(Y|X)$，定义为X给定条件下Y的条件概率分布的熵对X的数学期望$$H(Y|X)=\sum_{i=1}^{n}{p_iH(Y|X=x_i)}$$这里，$p_i=P(X=x_i),i=1,2,…,n.$</p><p>当熵和条件熵中的概率由数据估计得到时，所对应的熵和条件熵分别称为<em>经验熵</em>、<em>经验条件熵</em>。此时，如果有0概率，令$0log0=0$。<em>信息增益表示得知特征X的信息而使得类Y的信息的不确定性缺少的程度。</em></p><blockquote><p>定义5.2（信息增益）特征$A$对训练数据集D的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即$$g(D,A)=H(D)-H(D|A)$$一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为互信息。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p></blockquote><p>决策树学习应用信息增益准则选择特征。给定训练数据集D和特征A，经验熵$H(D)$表示对数据集$D$进行分类的不确定性。而经验条件熵$H(D|A)$表示在特征$A$给定的条件下对数据集D的不确定性。那么它们的差，即信息增益，就<strong>表示由于特征A而使得对数据集D的分类的不确定性减少的程度</strong>。显然，对于数据集D而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p><p>设训练数据为$D$，$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k$，$k=1,2,…,K$，$|C_k|$为属于类$C_k$的样本个数，$\sum_{k=1}^{K}{|C_k|=|D|}$。设特征$A$有$n$个不同的取值${a_1,a_2,…,a_n}$，根据特征A的取值将D划分为n个子集$D_1,D_2,…,D_n$，$|D_i|$为$D_i$的样本数量，$\sum_{i=1}^{n}{|D_i|=|D|}$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$，即$D_{ik}=D_i\cap C_k$，$D_{ik}$为$D_{ik}$的样本个数。于是信息增益的算法如下：</p><blockquote><p>算法5.1（信息增益的算法）<br>输入：训练数据$D$和特征$A$；<br>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$<br>(1)计算数据集D的经验熵$H(D)$$$H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|} log_2{\frac{C_k}{D}}}$$<br>(2)计算特征A对数据集D的经验条件熵$H(D|A)$$$H(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}H(D)}=-\sum_{i=1}^{n}{\frac{|D_{ik}|}{|D_i|}log_2\frac{|C_k|}{|D|}}$$<br>(3)计算信息熵$$g(D,A)=H(D)-H(D|A)$$</p></blockquote><h4 id="信息增益算法的实现"><a href="#信息增益算法的实现" class="headerlink" title="信息增益算法的实现"></a>信息增益算法的实现</h4><p>代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta"># 数据来源于P59页表5.1</span></span><br><span class="line"><span class="function">def <span class="title">get_data</span>(<span class="params"></span>):</span></span><br><span class="line"><span class="function">    dataSet </span>= [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],  <span class="meta"># 数据集</span></span><br><span class="line">               [<span class="meta">0, 0, 0, 1, 0</span>],</span><br><span class="line">               [<span class="meta">0, 1, 0, 1, 1</span>],</span><br><span class="line">               [<span class="meta">0, 1, 1, 0, 1</span>],</span><br><span class="line">               [<span class="meta">0, 0, 0, 0, 0</span>],</span><br><span class="line">               [<span class="meta">1, 0, 0, 0, 0</span>],</span><br><span class="line">               [<span class="meta">1, 0, 0, 1, 0</span>],</span><br><span class="line">               [<span class="meta">1, 1, 1, 1, 1</span>],</span><br><span class="line">               [<span class="meta">1, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">1, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 1, 1, 1</span>],</span><br><span class="line">               [<span class="meta">2, 1, 0, 1, 1</span>],</span><br><span class="line">               [<span class="meta">2, 1, 0, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 0, 0, 0</span>]]</span><br><span class="line">    X=np.zeros([len(dataSet),<span class="number">4</span>])</span><br><span class="line">    Y=np.zeros(len(dataSet))</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">len(dataSet</span>)):</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="title">range</span>(<span class="params"><span class="number">4</span></span>):</span></span><br><span class="line"><span class="function">            X[i][t]</span>=dataSet[i][t]</span><br><span class="line">        Y[i]=dataSet[i][<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> X,Y</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解经验熵H(x)</span></span><br><span class="line"><span class="function">def <span class="title">empirical_entropy</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    x_value_list </span>= <span class="keyword">set</span>([x[i] <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">x.shape[<span class="number">0</span>]</span>)])</span></span><br><span class="line"><span class="function">    ent </span>= <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        p = <span class="keyword">float</span>(x[x == x_value].shape[<span class="number">0</span>]) / x.shape[<span class="number">0</span>]</span><br><span class="line">        logp = np.log2(p)</span><br><span class="line">        ent -= p * logp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解经验条件熵H(y|x)</span></span><br><span class="line"><span class="function">def <span class="title">empirical_conditional_entropy</span>(<span class="params">x, y</span>):</span></span><br><span class="line"><span class="function">    x_value_list </span>= <span class="keyword">set</span>([x[i] <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">x.shape[<span class="number">0</span>]</span>)])</span></span><br><span class="line"><span class="function">    # <span class="title">print</span>(<span class="params">x_value_list</span>)</span></span><br><span class="line"><span class="function">    ent </span>= <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        sub_y = y[x == x_value]</span><br><span class="line">        temp_ent = empirical_entropy(sub_y)</span><br><span class="line">        ent += (<span class="keyword">float</span>(sub_y.shape[<span class="number">0</span>]) / y.shape[<span class="number">0</span>]) * temp_ent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解信息增益</span></span><br><span class="line"><span class="function">def <span class="title">information_gain</span>(<span class="params">x,y</span>):</span></span><br><span class="line"><span class="function">    base_ent </span>= empirical_entropy(y)</span><br><span class="line">    condition_ent = empirical_conditional_entropy(x, y)</span><br><span class="line">    ent_grap = base_ent - condition_ent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent_grap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    X,Y=get_data()</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"X"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(X)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"Y"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(Y)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"信息增益"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">X[<span class="number">0</span>].shape[<span class="number">0</span>]</span>):</span></span><br><span class="line"><span class="function">        <span class="title">print</span>(<span class="params"><span class="string">"g(D,A_"</span>+str(i</span>)+"): %.3f " % (<span class="params">information_gain(X[:,i],Y</span>)))</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/2018/10/19/决策树的原理及实现/QQ20181024-133943.png" alt="信息增益算法结果"></p><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><p>信息增益值的大小是相对于训练数据集而言的，并没有绝对意义。在分类问题困难时，也就是说在训练数据集的经验熵大的时候，信息增益值会偏大。反之，信息增益值会偏小。使用信息增益比可以怼这一问题进行校正。这是特征选择的另一准则。</p><blockquote><p>定义5.3（信息增益比）特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集D的经验熵$H(D)$之比：$$g_R(D,A)=\frac{g(D,A)}{H(D)}$$其中，$H_A(D)=-\sum_{i=1}^{n}log_2\frac{D_i}{D}$，n是特征A取值的个数。</p></blockquote><h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归地构建决策树。具体方法是：<strong>从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择为止。最后得到一棵决策树。</strong>ID3相当于用<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/3350286?fr=aladdin" target="_blank" rel="noopener">极大似然法</a>进行概率模型的选择。</p><blockquote><p>算法5.2（ID3算法）<br>输入：训练数据集D，特征集$A$，阈值$\varepsilon$<br>输出：决策树$T$<br>(1)若D中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$。<br>(2)若$A\ne\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(3)否则，按<a href="#信息增益"><strong>算法5.1</strong></a>计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$；<br>(4)<strong>如果$A_g$的信息增益小于阈值$\varepsilon$</strong>，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(5)否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；<br>(6)对$i$个子结点，以$D_i$为训练集，以$A-{A_g}$为特征集，递归地调用步(1)~(5)，得到子树$T_i$，返回$T_i$。</p></blockquote><h3 id="C4-5的生成算法"><a href="#C4-5的生成算法" class="headerlink" title="C4.5的生成算法"></a>C4.5的生成算法</h3><p>C4.5算法与ID3算法相似，是对其的一种改进，C4.5在生成的过程中，<strong>用信息增益比来选择特征</strong>。</p><blockquote><p>算法5.3（C4.5的生成算法）<br>输入：训练数据集$D$，特征集$A$，阈值$\varepsilon$；<br>输出：决策树$T$；<br>(1)如果$D$中所有实例属于同一类$C_k$，则置$T$为单结点树，并将$C_k$作为该结点的类，返回$T$；<br>(2)若$A\ne\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(3)否则，按<a href="#信息增益比"><strong>算法5.10</strong></a>计算$A$中各特征对$D$的信息增益比，选择信息增益比最大的特征$A_g$；<br>(4)<strong>如果$A_g$的信息增益小于阈值$\varepsilon$</strong>，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(5)否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；<br>(6)对$i$个子结点，以$D_i$为训练集，以$A-{A_g}$为特征集，递归地调用步(1)~(5)，得到子树$T_i$，返回$T_i$。</p></blockquote><h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>决策树通过递归来产生决策树，这样产生的树往往对训练数据分了很精确，但是在未知数据中不准确，即出现过拟合的现象。在决策树学习中将已生成的树进行简化的过程称为<strong>剪枝</strong>，具体地，剪枝从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为叶结点，从而简化决策树模型。</p><h3 id="剪枝所用的损失函数"><a href="#剪枝所用的损失函数" class="headerlink" title="剪枝所用的损失函数"></a>剪枝所用的损失函数</h3><p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树$T$的叶结点个数为$|T|$，t是树$T$的叶结点，该叶结点有$N_t$个样本点，其中k类的样本点有$N_{tk}$个，$k=1,2,…,K$，$H_t(T)$为叶结点$t$上的经验熵，$\alpha\ge0$为参数，则决策树学习的损失函数可以定义为$$C_{\alpha}(T)=\sum_{t=1}^{|T|}{N_tH_t(T)+\alpha{|T|}}\tag{5.11}$$其中经验熵为$$H_t(T)=-\sum_{k}\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t}\tag{5.12}$$在损失函数中，将式(5.11)右端的第1项记作$$C(T)=\sum_{t=1}^{|T|}=N_tH_t(T)=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}log\frac{N_{tk}}{N_t}\tag{5.13}$$这时有$$C_{\alpha}(T)=C(T)+\alpha{|T|}\tag{5.14}$$式(5.14)中，$C(T)$表示<strong>模型对训练数据的预测误差</strong>，即模型与训练数据的拟合度。$|T|$表示模型复杂度，参数$\alpha\ge0$控制两者之间的影响。较大的$\alpha$促使选择简单的模型，较大的$\alpha$促使选择较复杂的模型（树）。$\alpha=0$意味着只考虑模型与训练数据的拟合程度，<strong>不考虑模型的复杂度</strong>。</p><p>式(5.11)或式(5.14)定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p><p>图5.6就是决策树剪枝过程的示意图。<br><img src="/2018/10/19/决策树的原理及实现/WX20181027-180850.png" alt=""></p><blockquote><p>算法5.4（树的剪枝算法）<br>输入：生成算法产生的整个树$T$，参数$\alpha$；<br>输出：修剪后的子树$T_\alpha$。<br>(1)计算每个结点的经验熵。<br>(2)递归地从树的叶结点向上回缩。<br>设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别是$C_\alpha(T_B)$与$C_\alpha(T_A)$，如果$$C_\alpha(T_A)\le C_\alpha(T_B)\tag{5.15}$$则进行剪枝，即将父结点变成新的叶结点。<br>(3)返回(2)，直至不能继续为止，得到损失函数最小的子树$T_\alpha$。</p></blockquote><p>注意，式(5.15)只需考虑两个树的损失函数的差，其计算可以在局部进行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> python </tag>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>朴素贝叶斯法原理及实现</title>
      <link href="/2018/10/17/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/17/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对于给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯法实现简单，学习与预测的效率都很高，是一种常用的方法。</p><h2 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>设输入空间$\mathcal{X}\subseteq R_n$为n维向量的集合，输出空间为类标记集合$\mathcal{Y}=\{c_1,c_2,…,c_k\}$.输入为特征向量$x\in \mathcal{X}$，输出为类标记$y\in \mathcal{Y}$.X是定义在输入空间$\mathcal{X}$上的随机向量，Y是定义在输出空间$\mathcal{Y}$上的随机变量。$P(X,Y)$是X和Y的联合概率分布。训练数据集$$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$$由<em>$P(X,Y)$独立同分布</em>产生。</p><p>朴素贝叶斯法通过训练数据集学习联合概率分布$P(X,Y)$。具体地，学习以下<em>先验概率分布</em>及<em>条件概率分布</em>。先验概率分布$$P(Y=c_k)，k=1,2,…,K$$条件概率分布（后验概率分布）$$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k)$$于是学习到联合概率分布$P(X,Y)$.</p><p>条件概率分布$P(X=x|Y=c_k)$有指数级数量的参数，其估计实际是不可行的。事实上，假设$x^{(j)}$可取值有$S_j$个，$j=1,2,…,n$，Y可取值有K个，那么参数个数为$$K\prod_{j=1}^{n}S_j$$</p><p>朴素贝叶斯法对条件概率分布作了<em>条件独立性</em>的假设。由于这是一个较强的假设，朴素贝叶斯法也由此得名。朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说用于分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。</p><p>朴素贝叶斯法分类的基本公式：$$P(Y=c_k|X=x)=\frac{P(Y=c_k)\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_k P(Y=c_k) \prod_j (X^{(j)}=x^{(j)}|Y=c_k)}$$</p><p>朴素贝叶斯法分类器可表示为$$y=f(x)=arg \max_{c_k} P(Y=c_k) \prod_j P(X^{(j)}=x^{(j)}|Y=c_k)$$</p><h2 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)$和$P(X^{(j)}=x^{(j)}|Y=c_k)$.可以应用极大似然估计法估计相应的概率。<em>先验概率</em>$P(Y=c_k)$的极大似然估计是$$P(Y=c_k)=\frac {\sum_{i=1}^{N} I(y_i=c_k)} {N}，k=1,2,…,K$$设第$j$个特征$x^{(j)}$可能取值的集合为$\{a_{j1},a_{j2},…,a_{jS_j}\}$，条件概率$P(X^{j}=a_{jl}||Y=c_k)$的极大似然估计是$$P(x^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N} I(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)}\\j=1,2,…,n;l=1,2,…,S_j;k=1,2,…,K$$式中，$x_i^{(j)}$是第$i$个样本的第$j$个特征；$a_{jl}$是第$j$个特征可能取的第$l$个值：$I$为指示函数。</p><h3 id="学习与分类算法"><a href="#学习与分类算法" class="headerlink" title="学习与分类算法"></a>学习与分类算法</h3><blockquote><p>(朴素贝叶斯算法)<br>输入：训练数据$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$，其中$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})$，$x_i^{(j)}$是第$i$个样本的第$j$个特征，$x_i^{(j)}\in \{a_{j1},a_{j2},…,a_{jS_j}\}$，$a_{jl}$是第$j$个特征可能取的第$l$个值，$j=1,2,…,n$，$l=1,2,…,S_j$，$y_i\in \{c1,c2,…,c_k\}$；实例$x$；<br>输出：实例$x$的分类</p><ol><li>计算先验概率及条件概率$$P(Y=c_k)=\frac {\sum_{i=1}^{N} I(y_i=c_k)}{N},k=1,2,…,K\\P(X^{(j)}=a_{jl}|Y=c_k)=\frac {\sum_{i=1}^{(j)}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)}\\j=1,2,…,n；l=1,2,…,S_j；k=1,2,…,K$$</li><li>对于给定的实例$x=(x^{(1)},x^{(2)},…,x^{(n)})^T$，计算$$P(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=X^{(j)}|Y=c_k),k=1,2,…,K$$</li><li>确定实例$x$的类$$y=arg \max_{c_k} P(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$</li></ol></blockquote><h2 id="朴素贝叶斯算法在digits数据集上的实现"><a href="#朴素贝叶斯算法在digits数据集上的实现" class="headerlink" title="朴素贝叶斯算法在digits数据集上的实现"></a>朴素贝叶斯算法在digits数据集上的实现</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.datasets import load_digits</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_digits</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    digits = load_digits()</span><br><span class="line">    data = np.zeros([len(digits.data), len(digits.data[<span class="number">0</span>])])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits.data))<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(len(digits.data[<span class="number">0</span>]))<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> digits.data[i][t] &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">                data[i][t] = <span class="number">1</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                data[i][t] = <span class="number">0</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(data,np.array(digits.target) , test_size=<span class="number">0</span>.<span class="number">25</span>,random_state=<span class="number">33</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Naive_Bayes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(<span class="keyword">self</span>,X,Y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.P_Yc=np.zeros(<span class="number">10</span>)<span class="comment">#保存P(Y=c_k)</span></span><br><span class="line">        <span class="keyword">self</span>.I_Yc=np.zeros(<span class="number">10</span>)<span class="comment">#保存I(Y_i=c_k)</span></span><br><span class="line">        <span class="keyword">self</span>.I_XaYc=np.zeros((len(X[<span class="number">0</span>]),len([<span class="number">0</span>,<span class="number">1</span>]),<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Y))<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.I_Yc[Y[i]]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(len(X[<span class="number">0</span>]))<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.I_XaYc[t][ int(X[i][t]) ][Y[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.P_Yc=[i/sum(<span class="keyword">self</span>.I_Yc) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.I_Yc]</span><br><span class="line">        <span class="comment"># 第一项特征的数量，特征值的种类数量，分类的种类</span></span><br><span class="line">        <span class="keyword">self</span>.P_XaYc=np.zeros((len(X[<span class="number">0</span>]),len([<span class="number">0</span>,<span class="number">1</span>]),<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X[<span class="number">0</span>]))<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(len([<span class="number">0</span>,<span class="number">1</span>]))<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)<span class="symbol">:</span></span><br><span class="line">                    <span class="keyword">self</span>.P_XaYc[i][t][j]=<span class="keyword">self</span>.I_XaYc[i][t][j]/<span class="keyword">self</span>.I_Yc[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(<span class="keyword">self</span>,x)</span></span><span class="symbol">:</span></span><br><span class="line">        score=np.zeros(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="symbol">:</span></span><br><span class="line">            a=<span class="keyword">self</span>.P_Yc[i]</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(len(x))<span class="symbol">:</span></span><br><span class="line">                a*=<span class="keyword">self</span>.P_XaYc[t][int(x[t])][i]</span><br><span class="line">            score[i]=a</span><br><span class="line">        <span class="keyword">return</span> score.argmax()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># print(get_digits())</span></span><br><span class="line">    X_train, X_test, Y_train, y_test= get_digits()</span><br><span class="line">    nb=Naive_Bayes()</span><br><span class="line">    nb.train(X_train,Y_train)</span><br><span class="line">    t_num=<span class="number">0</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"预测过程"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_test))<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> nb.predict(X_test[i])==y_test[i]<span class="symbol">:</span></span><br><span class="line">            t_num+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"case"</span>,i,<span class="string">"，预测值："</span>,nb.predict(X_test[i]),<span class="string">"，真实值："</span>,y_test[i],<span class="string">"预测结果:"</span>,nb.predict(X_test[i])==y_test[i])</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"预测结果"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"准确率："</span>,t_num/len(y_test))</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/2018/10/17/朴素贝叶斯法原理及实现/QQ20181018-080645.png" alt="朴素贝叶斯法预测结果"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> python </tag>
            
            <tag> 朴素贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>K近邻算法的原理及实现</title>
      <link href="/2018/10/16/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/16/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习并实现完了之前的感知机算法，感觉它是比较简单的，并且只能进行处理线性分类问题。<br><br>本章节学习了K近邻算法（k-nearest neighbor,k-NN），它是一种基本分类与回归方法，在这一章节中，不介绍它在回归问题中的应用，仅仅介绍其在分类问题中的应用。K近邻算法的输入为实例的特征向量，对应于特征空间的点，输出为实例的类别。</p><h2 id="k近邻算法"><a href="#k近邻算法" class="headerlink" title="k近邻算法"></a>k近邻算法</h2><p>通俗的说：给定一个数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类（多数表决投票）。</p><blockquote><p>输入：训练数据集$T=\{(x_1,y_1),(x_1,y_2),…,(x_N,y_N)\}$其中，$x_i\in \mathcal{X}\subseteq R^n$为实例的特征向量，$y_i\in \mathcal{Y}={c_1,c_2,…,c_k}$为实例的类别，$i=1,2,…,N$；实例特征向量$x$；<br>输出：在$N_k(x)$中根据分类决策规则（如多数表决）决定$x$的类别$y$:<br><br>$$y=\mathop{\arg\max}_{c_j} \sum_{x_i\in N_k (x)} I(y_i=c_j),i=1,2,…,N;j=1,2,…,K$$<br>I为指示函数，即当$y_i=c_i$时I为1，否则I为0.</p></blockquote><p>当k近邻法的k=1时，就是特殊情形，也就是最近邻算法，对于输入的实例点（特征向量）$x$，最近邻法将训练数据集中与$x$最邻近点的类作为$x$的类。<em>k近邻算法没有显式的学习过程。</em></p><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>如《统计学习方法》概论总结中所说，距离的度量方法有很多，特征空间中两个实例点的距离是两个实例点相似程度的反映。k近邻模型的特征空间一般是$n$维实数向量空间$R^n$。使用的距离是欧氏距离，但也可以是其他距离，如更一般的$L_p$距离或Minkowski距离。这里就不再赘述了。</p><h3 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h3><p>k值的选择会对k近邻法的结果产生重大影响。</p><p>如果选择较小的k值，就相当于用较小的邻域中的训练实例进行预测，“学习”的近似误差会减小，只有于输入实例相近的训练实例才会对预测结果起作用。但是缺点是“学习”的估计误差会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，k值的减小就意味着整体模型变得复杂，容易发生过拟合。</p><p>如果选择较大的k值，就相当于用较大领域中的训练实例进行预测。其优点是可以减少学习的估计误差。但缺点是学习的近似误差会增大。这时与输入实例较远的训练实例也会对预测起作用，使预测发生错误。k值的增大就意味着整体的模型变得简单。</p><p>在应用中，k值一般选择一个比较小的数值。通常采用交叉验证法来选取最优的k值。</p><h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>k近邻法中的分类决策规则往往是多数表决，即由输入实例的k个邻近的训练实例中的多数类决定输入实例的类。<br>多数表决规则有如下解释：如果分类的损失函数为0-1损失函数，分类函数为$$f:R^n \to \{c_1,c_2,…,c_k\}$$<br>那么误分类的概率是<br>$$P(Y\ne f(X))=1-P(Y=f(X))$$<br>对给定的实例$x\in X$，其最近邻的k个训练实例点构成集合$N_k(x)$。如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是<br>$$\frac{1}{k} \sum_{x_i \in N_k(x)} I(y_i \ne c_j)=1- \frac{1}{k} \sum_{x_i\in N_(x)} I(y_i=c_j)$$<br>要使误分类绿最小即经验风险最小，就要使$\sum_{x_i\in N_k(x)} I(y_i=c_j)$最大，所以多数表决规则等于经验风险最小化。</p><h2 id="KNN的实现"><a href="#KNN的实现" class="headerlink" title="KNN的实现"></a>KNN的实现</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 仅使用sklearn中的iris数据集，以及归一化、数据拆分函数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIrisData</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    data=load_iris()</span><br><span class="line">    X=np.array(data.data)</span><br><span class="line">    Y=np.array(data.target)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># X数据归一化处理</span></span><br><span class="line">    min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">    X = min_max_scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据拆分，测试数据占比0.3</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = <span class="number">0.2</span>, random_state = <span class="number">33</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># k值设定，可以根据需要更改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,k=<span class="number">11</span>)</span>:</span></span><br><span class="line">        self.k=k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向当前knn模型中注入原始数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self,X,Y)</span>:</span></span><br><span class="line">        self.size=len(X[<span class="number">0</span>])</span><br><span class="line">        self.cells=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Y)):</span><br><span class="line">            self.cells.append(cell(X[i],Y[i]))</span><br><span class="line">        <span class="comment"># print(self.cells)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用模型进行预测</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment"># 创建投票列表</span></span><br><span class="line">        Nk=sorted(self.cells,key=<span class="keyword">lambda</span> cell:np.linalg.norm(cell.x-x))[:self.k] <span class="comment">#使用的np.linalg.norm函数在默认情况下求解的为范数为2的范式</span></span><br><span class="line">        <span class="comment"># 多数表决投票</span></span><br><span class="line">        ans=np.zeros(<span class="number">4</span>,float)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Nk:</span><br><span class="line">            ans[i.y]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print("*" * 10, "置信度", "*" * 10)</span></span><br><span class="line">        ans=ans/self.k</span><br><span class="line">        <span class="comment"># print(ans)</span></span><br><span class="line">        <span class="keyword">return</span> ans.argmax(),ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    X_train, X_test, y_train, y_test=getIrisData()</span><br><span class="line">    knn=KNN()</span><br><span class="line">    knn.train(X_train,y_train)</span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">10</span>, <span class="string">"预测"</span>, <span class="string">"*"</span> * <span class="number">10</span>)</span><br><span class="line">    t_num=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_test)):</span><br><span class="line">        p_y,ans=knn.predict(X_test[i])</span><br><span class="line">        <span class="keyword">if</span> p_y==y_test[i]:</span><br><span class="line">            t_num+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"各参数:"</span>,X_test[i],<span class="string">"真实类:"</span>,y_test[i],<span class="string">"预测类:"</span>,p_y,<span class="string">"是否正确:"</span>,p_y==y_test[i],<span class="string">"置信度:"</span>,ans)</span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">10</span>, <span class="string">"结果"</span>, <span class="string">"*"</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"iris数据集中，交叉验证正确率：&#123;:2f&#125;"</span>.format(t_num/len(y_test)))</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/2018/10/16/K近邻算法的原理及实现/QQ20181017-133128.png" alt="KNN在iris数据集中的效果"></p><h2 id="kd树寻找最邻近算法"><a href="#kd树寻找最邻近算法" class="headerlink" title="kd树寻找最邻近算法"></a>kd树寻找最邻近算法</h2><h3 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h3><blockquote><p>构造平衡kd树算法：<br>输入：k维空间数据集$T=\{x_1,x_2,…,x_N\}$，<br>其中$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(k)})^T$,$i=1,2,…,N;$<br>输出：kd树<br>（1）开始：构造根节点，根节点对应于包括T的k维空间的超矩形区域。<br>选择$x^{(1)}$为坐标轴，以T中所有实例$x^{(1)}$坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。<br>由根结点生成深度为1的左、右子结点：左子结点对应坐标$x^{(1)}$小与切分点的子区域，右子结点对于坐标$x^{(1)}$大于切分点的子区域。<br>将落在切分超平面上的实例点保存在根结点。<br>（2）重复：对深度为j的结点，选择$x^{(l)}$为切分的坐标轴，$l=j(mod k)+1$，以该结点的区域中所有实例的$x^{(l)}$坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(l)}$垂直的超平面实现。<br>由该结点生成深度为$j+1$的左、右子结点：左子结点对应坐标$x^{(l)}$小与切分点的子区域，右子结点对应坐标$x^{(l)}$大于切分点的子区域。<br>将落在切分超平面上的实例点保存在该结点。<br>（3）直到两个子区域没有实例存在时停止，从而形成kd树的区域划分。</p></blockquote><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><blockquote><p>用kd树的<em>最邻近</em>搜索：<br><br>输入：已够早的kd树：目标点x<br>输出：x的最近邻<br>(1)在kd树种找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd树，若目标点x当前维的坐标小与切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。<br>(2)以此叶结点为“当前最近点”<br>(3)递归地向上回退，在每个结点进行以下操作：</p><blockquote><p>(a)如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”<br>(b)当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。具体地，检查另一子结点对应的区域是否与目标点为球心，以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点。移动到另一个子结点，接着，递归地进行最邻近搜索。如果不相交，向上回退。</p></blockquote></blockquote><blockquote><p>(4)当回退到根结点时，搜索结束，最后的“当前最近点”即为x的最邻近点。</p></blockquote><h2 id="kd树查找最近邻的实现"><a href="#kd树查找最近邻的实现" class="headerlink" title="kd树查找最近邻的实现"></a>kd树查找最近邻的实现</h2><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造kd树，P41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDnode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dome_point,split_num,left,right)</span>:</span></span><br><span class="line">        self.dome_point=dome_point  <span class="comment">#此次样本点</span></span><br><span class="line">        self.split_num=split_num    <span class="comment">#切割的维度号</span></span><br><span class="line">        self.left=left              <span class="comment">#左子树</span></span><br><span class="line">        self.right=right            <span class="comment">#右子树</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDtree</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        k=len(data[<span class="number">0</span>])              <span class="comment">#k维度</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">CreateNode</span><span class="params">(split_num,data_set)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data_set :       <span class="comment">#data_set为空返回空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            data_set.sort(key=<span class="keyword">lambda</span> x : x[split_num])  <span class="comment">#按照我们想要切割的维度号进行排序</span></span><br><span class="line">            split_pos=len(data_set)//<span class="number">2</span>                  <span class="comment">#从中间将其分割开，获得中位点标号</span></span><br><span class="line">            middle_pos=data_set[split_pos]              <span class="comment">#找到中位点</span></span><br><span class="line">            split_next=(split_num+<span class="number">1</span>)%k                  <span class="comment">#下一个需要分割的维度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> KDnode(middle_pos,split_num,</span><br><span class="line">                          CreateNode(split_next,data_set[:split_pos]),</span><br><span class="line">                          CreateNode(split_next,data_set[split_pos+<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line">        self.root=CreateNode(<span class="number">0</span>,data)    <span class="comment">#创造树</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找最近点，参考学习了https://www.cnblogs.com/21207-iHome/p/6084670.html</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(tree, point)</span>:</span></span><br><span class="line">    k = len(point)  <span class="comment"># 数据维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(kd_node, target, max_dist)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> kd_node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>] * k, float(<span class="string">"inf"</span>), <span class="number">0</span>  <span class="comment"># python中用float("inf")和float("-inf")表示正负无穷</span></span><br><span class="line">                                            <span class="comment"># return的参数分别是最近坐标点、最近距离和访问过的节点数</span></span><br><span class="line"></span><br><span class="line">        nodes_visited = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s = kd_node.split_num  <span class="comment"># 进行分割的维度</span></span><br><span class="line">        pivot = kd_node.dome_point  <span class="comment"># 进行分割的“轴”</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target[s] &lt;= pivot[s]:  <span class="comment"># 如果目标点第s维小于分割轴的对应值(目标离左子树更近)</span></span><br><span class="line">            nearer_node = kd_node.left  <span class="comment"># 下一个访问节点为左子树根节点</span></span><br><span class="line">            further_node = kd_node.right  <span class="comment"># 同时记录下右子树</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 目标离右子树更近</span></span><br><span class="line">            nearer_node = kd_node.right  <span class="comment"># 下一个访问节点为右子树根节点</span></span><br><span class="line">            further_node = kd_node.left</span><br><span class="line"></span><br><span class="line">        temp1 = travel(nearer_node, target, max_dist)  <span class="comment"># 进行遍历找到包含目标点的区域</span></span><br><span class="line"></span><br><span class="line">        nearest = temp1[<span class="number">0</span>]  <span class="comment"># 以此叶结点作为“当前最近点”</span></span><br><span class="line">        dist = temp1[<span class="number">1</span>]  <span class="comment"># 更新最近距离</span></span><br><span class="line"></span><br><span class="line">        nodes_visited += temp1[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dist &lt; max_dist:</span><br><span class="line">            max_dist = dist  <span class="comment"># 最近点将在以目标点为球心，max_dist为半径的超球体内</span></span><br><span class="line"></span><br><span class="line">        temp_dist = abs(pivot[s] - target[s])  <span class="comment"># 第s维上目标点与分割超平面的距离</span></span><br><span class="line">        <span class="keyword">if</span> max_dist &lt; temp_dist:  <span class="comment"># 判断超球体是否与超平面相交</span></span><br><span class="line">            <span class="keyword">return</span> nearest, dist, nodes_visited  <span class="comment"># 不相交则可以直接返回，不用继续判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 计算目标点与分割点的欧氏距离</span></span><br><span class="line">        temp_dist=np.linalg.norm((np.array(pivot)-np.array(target)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> temp_dist &lt; dist:  <span class="comment"># 如果“更近”</span></span><br><span class="line">            nearest = pivot  <span class="comment"># 更新最近点</span></span><br><span class="line">            dist = temp_dist  <span class="comment"># 更新最近距离</span></span><br><span class="line">            max_dist = dist  <span class="comment"># 更新超球体半径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查另一个子结点对应的区域是否有更近的点</span></span><br><span class="line">        temp2 = travel(further_node, target, max_dist)</span><br><span class="line"></span><br><span class="line">        nodes_visited += temp2[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> temp2[<span class="number">1</span>] &lt; dist:  <span class="comment"># 如果另一个子结点内存在更近距离</span></span><br><span class="line">            nearest = temp2[<span class="number">0</span>]  <span class="comment"># 更新最近点</span></span><br><span class="line">            dist = temp2[<span class="number">1</span>]  <span class="comment"># 更新最近距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nearest, dist, nodes_visited</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> travel(tree.root, point, float(<span class="string">"inf"</span>))  <span class="comment"># 从根节点开始递归</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先left后right，前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    print(root.dome_point)</span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        preorder(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        preorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data=[[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>]]     <span class="comment">#书上P42例子</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"data"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(data)</span><br><span class="line">    kd=KDtree(data)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"先序遍历"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    preorder(kd.root)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"search"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(search(kd,[<span class="number">5</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="/2018/10/16/K近邻算法的原理及实现/QQ20181017-133411.png" alt="kd树寻找最邻近点的结果"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> python </tag>
            
            <tag> K近邻 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo中文章的两种创建方法及加密</title>
      <link href="/2018/10/15/Hexo%E4%B8%AD%E6%96%87%E7%AB%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8A%A0%E5%AF%86/"/>
      <url>/2018/10/15/Hexo%E4%B8%AD%E6%96%87%E7%AB%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在每次写笔记的时候，一天肯定是写不完的，但是又不希望直接<code>clean g d</code>了，因此想使用草稿的功能，鸣谢<a href="https://blog.csdn.net/wizardforcel/article/details/40684575" target="_blank" rel="noopener">https://blog.csdn.net/wizardforcel/article/details/40684575</a>找到了使用草稿功能的方法。</p><h2 id="写文章的步骤"><a href="#写文章的步骤" class="headerlink" title="写文章的步骤"></a>写文章的步骤</h2><p>回顾一下正常写文章的步骤：<br>首先创建一个名叫<code>name</code>的文章<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"name"</span></span><br></pre></td></tr></table></figure></p><p>接着系统会提示文章保存在<code>/sources/_post</code>里面，然后书写文章，直至完毕。<br>然后就是同步预览文章和提交github pages的时间了。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure></p><p>此刻就完成了写文章的标准步骤。</p><h2 id="写草稿的步骤"><a href="#写草稿的步骤" class="headerlink" title="写草稿的步骤"></a>写草稿的步骤</h2><p>接下来讲写草稿的步骤：<br>首先创建一个草稿<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">draft</span> <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure></p><p>会在<code>source/_drafts</code>目录下生成一个<code>new-draft.md</code>文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到<code>_drafts</code>目录之中。<br>如果你希望强行预览草稿，更改配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>或者，如下方式启动server：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo<span class="built_in"> server </span>--drafts</span><br></pre></td></tr></table></figure></p><p>下面这条命令可以把草稿变成文章，或者页面：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish <span class="string">[layout]</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure></p><h2 id="加密文章的方法"><a href="#加密文章的方法" class="headerlink" title="加密文章的方法"></a>加密文章的方法</h2><p>我们所书写的一些文章，总会因为一些原因不想让大家看到，比如：文章未完成、涉及个人隐私等等。因此想要将它加密一下。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在此，我们使用的是<code>hexo-blog-encrypt</code>，并且得在<code>2.0</code>版本以上,然后执行<code>npm install</code>命令。然后该插件会自动安装。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="1、首先在-config-yml中启用该插件"><a href="#1、首先在-config-yml中启用该插件" class="headerlink" title="1、首先在_config.yml中启用该插件:"></a>1、首先在<code>_config.yml</code>中启用该插件:</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2、在你的文章的头部添加上对应的字段，如password-message"><a href="#2、在你的文章的头部添加上对应的字段，如password-message" class="headerlink" title="2、在你的文章的头部添加上对应的字段，如password,message"></a>2、在你的文章的头部添加上对应的字段，如<code>password</code>,<code>message</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">加密测试</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-10</span><span class="bullet">-15</span> <span class="number">18</span><span class="string">:48:35</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">加密测试</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">passwd</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">欢迎来到我的博客，由于一些原因，请输入密码查看。</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>如果要取消加密，在<code>password</code>之前用<code>#</code>注释掉即可。</p><h4 id="3、加密效果"><a href="#3、加密效果" class="headerlink" title="3、加密效果"></a>3、加密效果</h4><p><img src="/2018/10/15/Hexo中文章的两种创建方法及加密/QQ20181015-191701.png" alt="加密效果展示"></p>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>更改hexo中的Mathjax引擎</title>
      <link href="/2018/10/14/%E6%9B%B4%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84Mathjax%E5%BC%95%E6%93%8E/"/>
      <url>/2018/10/14/%E6%9B%B4%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84Mathjax%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建的博客在使用Math引擎构建数学公式的时候遇到了几个问题。</p><ul><li>显示公式出错，显示的是语法错误</li><li>不能使用<code>$...$</code>行内公式</li><li>显示的公式十分丑</li></ul><p>在网上也看到了很多的答案，但是都不是很靠谱啊。真的是个大坑啊啊啊，看<a href="https://docs.mathjax.org/en/latest/mathjax.html" target="_blank" rel="noopener">官方文档</a>看了好久，然后又去找的Hexo的实现方法。emmm，索性解决了。</p><h3 id="找到自己模板配置"><a href="#找到自己模板配置" class="headerlink" title="找到自己模板配置"></a>找到自己模板配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd themes<span class="regexp">/maupassant/</span></span><br><span class="line"><span class="comment"># 找到head的配置文件，我的模板中head等的配置文件是在这里，其他的可以自己找找</span></span><br><span class="line">cd layout<span class="regexp">/_partial/</span></span><br></pre></td></tr></table></figure><p>layout/_partial/下就是该模板的配置信息了，然后看一下是否有mathjax.pug（部分模板是html格式或其他格式，无所谓），如果有的话，选择方案一，如果没有，选择方案二。</p><p>优先推荐方案一，因为这样可以只在使用mathjax的页面进行渲染，速度更加快。</p><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><h3 id="只需要修改mathjax-pug"><a href="#只需要修改mathjax-pug" class="headerlink" title="只需要修改mathjax.pug"></a>只需要修改mathjax.pug</h3><p>在某些模板中，有着自己的mathjax.pug，那么只需要将js相应部分改为以下的pug代码即可。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">script(type=<span class="string">"text/x-mathjax-config"</span>).</span><br><span class="line">    <span class="symbol">MathJax</span>.<span class="symbol">Hub</span>.<span class="symbol">Config</span>(&#123;</span><br><span class="line">    extensions: [<span class="string">"tex2jax.js"</span>],</span><br><span class="line">    jax: [<span class="string">"input/TeX"</span>, <span class="string">"output/HTML-CSS"</span>],</span><br><span class="line">    tex2jax: &#123;</span><br><span class="line">        inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span><br><span class="line">        displayMath: [ [<span class="string">'$$'</span>,<span class="string">'$$'</span>], [<span class="string">"\\["</span>,<span class="string">"\\]"</span>] ],</span><br><span class="line">        processEscapes: true</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="string">"HTML-CSS"</span>: &#123; fonts: [<span class="string">"TeX"</span>] &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">script(type=<span class="string">"text/javascript"</span> src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"</span>)</span><br></pre></td></tr></table></figure><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>若mathjax不是单独配置的话，按照以下步骤进行。</p><h3 id="关闭hexo本身的mathjax"><a href="#关闭hexo本身的mathjax" class="headerlink" title="关闭hexo本身的mathjax"></a>关闭hexo本身的mathjax</h3><p>关闭hexo本身的mathjax，也就是在HEXO目录下的_config.yml，改为<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>然后关闭相应文章的<code>front-matter</code>中的<code>mathjax: true</code></p><h3 id="修改主题模板"><a href="#修改主题模板" class="headerlink" title="修改主题模板"></a>修改主题模板</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改<span class="selector-tag">head</span><span class="selector-class">.pug</span>，为了让全局页面中加入<span class="selector-tag">mathjax</span></span><br><span class="line"><span class="selector-tag">vim</span> <span class="selector-tag">head</span><span class="selector-class">.pug</span></span><br></pre></td></tr></table></figure><p>然后就在其中加入我们需要的mathjax<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">script(type=<span class="string">"text/x-mathjax-config"</span>).</span><br><span class="line">    <span class="symbol">MathJax</span>.<span class="symbol">Hub</span>.<span class="symbol">Config</span>(&#123;</span><br><span class="line">    extensions: [<span class="string">"tex2jax.js"</span>],</span><br><span class="line">    jax: [<span class="string">"input/TeX"</span>, <span class="string">"output/HTML-CSS"</span>],</span><br><span class="line">    tex2jax: &#123;</span><br><span class="line">        inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span><br><span class="line">        displayMath: [ [<span class="string">'$$'</span>,<span class="string">'$$'</span>], [<span class="string">"\\["</span>,<span class="string">"\\]"</span>] ],</span><br><span class="line">        processEscapes: true</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="string">"HTML-CSS"</span>: &#123; fonts: [<span class="string">"TeX"</span>] &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">script(type=<span class="string">"text/javascript"</span> src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"</span>)</span><br></pre></td></tr></table></figure></p><p>因为pug格式和html相似，因此如果格式是html的话，可以自己更改一下。</p><h2 id="修改前后对比"><a href="#修改前后对比" class="headerlink" title="修改前后对比"></a>修改前后对比</h2><h3 id="修改前"><a href="#修改前" class="headerlink" title="修改前"></a>修改前</h3><p><img src="/2018/10/14/更改hexo博客中的Mathjax引擎/E7217D6653FB277C412019A200AE3D19.png" alt="修改前的0-1损失函数" title="修改前的0-1损失函数"></p><h3 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h3><p>$$L(Y,f(x))=\begin{cases}<br>    1,&amp; Y \ne f(X)\\<br>    0,&amp; Y = f(X)<br>\end{cases}$$</p><p>$$<br>\begin{matrix}<br>    1 &amp; x &amp; x^2 \\<br>    1 &amp; y &amp; y^2 \\<br>    1 &amp; z &amp; z^2 \\<br>\end{matrix}<br>$$</p><blockquote><p>PS:在该版本中，换行符是<code>\\\</code>，而不是两个<code>\</code>，请在测试的时候注意一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac配置ssh免密登录腾讯云服务器</title>
      <link href="/2018/10/13/mac%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/10/13/mac%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在前一段时间，斥巨资购买了一年的云服务器，但是一直落着吃灰，今天忽然想起来折腾一下。</p><p><br></p><h2 id="ssh直连"><a href="#ssh直连" class="headerlink" title="ssh直连"></a>ssh直连</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i ~/.ssh/<span class="string">[密钥名称]</span> <span class="string">[账户]</span>@<span class="string">[ip地址]</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-165116.png" alt="连接上的效果" title="连接上的效果"></p><p>可以看到我们已经连接上了腾讯云服务器，但是是不是每次都需要输入很长的ip地址，这就很烦了，因此接下来我们设置一下hosts，用代号替换ip地址。</p><h2 id="设置hosts"><a href="#设置hosts" class="headerlink" title="设置hosts"></a>设置hosts</h2><p>以下以mac osx系统为例<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure></p><p>然后直接在最后加上你的云服务器ip地址和想要表示的名字。<br>或者用下面的语句直接添加：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"[ip地址]  [替代名]"</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-165910.png" alt="修改后的样子" title="修改后的样子"></p><h3 id="设置免密登录"><a href="#设置免密登录" class="headerlink" title="设置免密登录"></a>设置免密登录</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd .ssh</span><br><span class="line"><span class="variable">$ </span>ssh-keygen</span><br><span class="line"><span class="variable">$ </span>ssh-copy-id ubuntu<span class="variable">@t_cloud</span></span><br></pre></td></tr></table></figure><p>首先进入.ssh目录，生成密钥，然后将公钥传给云服务器。注意：在腾讯云服务器中，默认的用户是ubuntu，而不是root。</p><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-170408.png" alt="密钥传送完毕" title="密钥传送完毕"></p><p>最后尝试免密登录吧</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> ubuntu<span class="variable">@t_cloud</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/13/mac配置ssh免密登录腾讯云服务器/QQ20181013-170625.png" alt="免密登录成功" title="免密登录成功"></p><p>这样就免密登录成功了，再也不需要繁琐的输入密码了！</p>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>感知机的原理及实现</title>
      <link href="/2018/10/10/%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/10/%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过第一章漫长的学习，终于进入到了算法的学习，也很激动地开始了对感知机的学习。</p><h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><h3 id="感知机的定义"><a href="#感知机的定义" class="headerlink" title="感知机的定义"></a>感知机的定义</h3><blockquote><p>假设输入空间（特征空间）是$\mathcal{X} \subseteq R^n$，输出空间是$\mathcal{Y}=\{+1,-1\}$，输入$x\in\mathcal{X}$表示实例的特征向量，对应于输入空间（特征空间）的点；输出$y\in\mathcal{Y}$表示实例的类别，由输入空间到输出空间的如下函数：<br>$$f(x)=sign(w\bullet x+b)$$<br>称为感知机，其中，w和b为感知机模型参数，$w\in R^n$叫作权值（weight）或权值向量（weight vector），$b\in R$叫作偏置（biss），$w\bullet x$表示w和x的内积，sign表示符号函数，即：<br>$$sign(x)=\begin{cases}<br> +1,x\ge 0 \\<br>-1,x&lt;0\end{cases}$$<br>感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型或线性分类器，即函数集合$ \{ f|f(x)=w\bullet x+b=0 \} $</p></blockquote><p>对于特征空间$R^n$中的一个超平面$S$，其中w是超平面的法向量，$b$是超平面的截距。这个超平面将特征空间划分为两个部分，位于两部分的点（特征向量）分别被分为正、负两类，因此超平面S被称为分离超平面。如下图所示:</p><p><img src="/2018/10/10/感知机的原理及实现/感知机模型.png" alt="感知机模型"></p><h2 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h2><h3 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h3><blockquote><p>定义(数据集的线性可分性)：给定一个数据集$$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$$<br>其中$x_i\in \mathcal{X}=R^n$,$y_i\in \mathcal{Y}=\{+1,-1\}$，$i=1,2,…,N$，如果存在某个超平面$S$$$w\bullet x_i +b &lt;0$$能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有$y_i=+1$的实例$i$，有$w\bullet x_i+b&gt;0$，对所有$y_i=1$的实例$i$，有$w\bullet x_i+b&lt;0$，则称数据集T为线性可分数据集，否则称数据集T线性不可分。</p></blockquote><p>在我的理解中，问题的关键在于存不存在一个超平面将所有的数据集按照正例负例分割开来，若存在，则线性可分；不存在，则线性不可分。</p><h3 id="感知机学习策略-1"><a href="#感知机学习策略-1" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h3><p>如果训练数据集是线性可分的，感知机学习的目标是找到能够将正、负实例点完全正确分开的<code>分离超平面</code>，为了找到这样的超平面，我们也就要找到感知机的参数，因此需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。</p><p>损失函数的选择有很多，最简单的一个就是<code>误分点的个数</code>，但是这样的损失函数并不是参数w、b的连续可导函数，不容易优化。另一个选择则是<code>误分类点到超平面S的总距离</code>，这个是感知机所采用的。<br>输入空间$R^n$中任一点$x_0$到超平面S的距离：<br>$$\frac {1}{||w||} |w\bullet x_0+b|，其中||w||是w的L_2范数$$<br>其次，对于误分类的数据$(x_i,y_i)$，来说$$-y_i(w\bullet x_i+b)&gt;0$$成立,也意味着预测得到值和真实值符号相反。<br>这样，假设超平面S的误分类点集合为M，那么所有误分类点到超平面S的总距离为：$$-\frac{1}{||w||} \sum_{x_i\in M}{y_i(w\bullet x_i+b)}$$不考虑$\frac{1}{||w||}$，就得到感知机学习的损失函数.<br>$$L(w,b)=-\sum_{x_i\in M}{y_i(w\bullet x_i+b)}$$<br>其中，$M$是误分类点的集合，这个损失函数就是感知机学习的经验风险函数。<br>可以看出，损失函数$L(w,b)$是非负的，如果没有误分类点，损失函数值是0.而误分类点越少，误分类点距离超平面也就越近，损失函数值就越小。一个特定的样本点的损失函数：在误分类时是参数$w,b$的线性函数，在正确分类时为0，因此在给定训练数据T，损失函数$L(w,b)$是$w，b$的连续可导函数。</p><h2 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h2><h3 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h3><p>感知机算法其实就是求解损失函数极小化问题的解$$\min_{w,b} L(w,b)=-\sum_{x_i\in M} y_i(w\bullet x_i +b)$$<br>感知机学习算法是由误分类驱动的，具体采用随机梯度下降法，过程是首先，任意选取一个超平面$w_0,b_0$，然后用梯度下降法不断地极小化目标函数，一次随机选取一个误分类点使其梯度下降。<br>假设误分类点集合M是固定的，那么损失函数$L(w,b)$的梯度如下：</p><p>$$\nabla_w L(w,b)=-\sum_{x_i\in M} y_ix_i\\<br>\nabla_b L(w,b)=-\sum_{x_i\in M} y_i$$</p><p>随机选取一个误分类点$(x_i,y_i)$，对$w,b$进行更新：</p><p>$$w \gets w+\eta y_ix_i \\<br>b \gets b+\eta y_i$$</p><p>其中，式子中的$\eta$是步长，也就是我们熟知的学习率(learning rate)。</p><h3 id="感知机学习算法的原始形式算法"><a href="#感知机学习算法的原始形式算法" class="headerlink" title="感知机学习算法的原始形式算法"></a>感知机学习算法的原始形式算法</h3><blockquote><p>输入：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中$x_i \in \mathcal{X} = R^n$，$y_i \in \mathcal{Y}=\{-1,+1\}$，$i=1,2,…,N$，学习率$\eta(0&lt;\eta\le 1);$<br>输出：$w,b$，感知机模型$f(x)=sign(w\bullet x+b)$.</p><ol><li>选取初值$w_0,b_0$</li><li>在训练集中选取数据$(x_i,y_i)$</li><li>如果$y_i(w\bullet x_i+b)\le 0$ $$w \gets w+\eta y_ix_i$$$$b \gets b+\eta y_i$$</li><li>转至2步骤，直至训练集中没有误分类点。</li></ol></blockquote><p>这种学习方法在直观上有如下解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整$w,b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直至超平面越过该分类点使其被正确分类。</p><h3 id="感知机学习算法的原始形式的实现"><a href="#感知机学习算法的原始形式的实现" class="headerlink" title="感知机学习算法的原始形式的实现"></a>感知机学习算法的原始形式的实现</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>根据上述的原始形式算法，直接构建算法模型，数据是通过公式创造的，然后用于分类，实现如下：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">random</span></span><br><span class="line">import numpy as <span class="built_in">np</span></span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"># 创建数据集</span><br><span class="line">def createData(t_w,t_b,num_size):</span><br><span class="line">    <span class="built_in">random</span>.seed(<span class="number">78</span>)</span><br><span class="line">    x,y=[],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_size):</span><br><span class="line">        x.<span class="built_in">append</span>([<span class="built_in">random</span>.uniform(<span class="number">0</span>,<span class="number">10</span>),<span class="built_in">random</span>.uniform(<span class="number">0</span>,<span class="number">10</span>)])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        sy=i[<span class="number">0</span>]*t_w[<span class="number">0</span>]+i[<span class="number">1</span>]*t_w[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> sy&gt;t_b:</span><br><span class="line">            y.<span class="built_in">append</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.<span class="built_in">append</span>(-<span class="number">1</span>)</span><br><span class="line">    x=<span class="built_in">np</span>.<span class="built_in">array</span>(x)</span><br><span class="line">    y=<span class="built_in">np</span>.<span class="built_in">array</span>(y)</span><br><span class="line">    <span class="built_in">return</span> x,y</span><br><span class="line"></span><br><span class="line">#训练过程</span><br><span class="line">def train(x,y,learning_rate):</span><br><span class="line">    w=<span class="built_in">np</span>.<span class="built_in">array</span>([<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    b=<span class="number">0</span></span><br><span class="line">    finish_flag=False</span><br><span class="line">    <span class="built_in">num</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> finish_flag):</span><br><span class="line">        <span class="built_in">num</span>+=<span class="number">1</span></span><br><span class="line">        finish_flag=True</span><br><span class="line">        f_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(y)):</span><br><span class="line">            <span class="keyword">if</span> y[i]*(<span class="built_in">np</span>.dot(w,x[i])+b)&lt;=<span class="number">0</span>:</span><br><span class="line">                w=w+learning_rate*y[i]*x[i]</span><br><span class="line">                b=b+learning_rate*y[i]</span><br><span class="line">                finish_flag=False</span><br><span class="line">                f_num+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Traversing the &#123;&#125; times ,w= [&#123;:.2f&#125;,&#123;:.2f&#125;] b= &#123;:.2f&#125; accuracy= &#123;:.2f&#125;."</span>.format(<span class="built_in">num</span>,w[<span class="number">0</span>],w[<span class="number">1</span>],b,(<span class="number">10</span>-f_num)/<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">return</span> w,b</span><br><span class="line"></span><br><span class="line">#预测出来的model</span><br><span class="line">def f(w,b):</span><br><span class="line">    x1 = <span class="built_in">np</span>.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">return</span> x1,[-(w[<span class="number">0</span>]*i+b)/w[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x1]</span><br><span class="line"></span><br><span class="line">#图像展示</span><br><span class="line">def <span class="built_in">show</span>(x,y,w,b):</span><br><span class="line">    x1=<span class="built_in">np</span>.dot(x,[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">    x2=<span class="built_in">np</span>.dot(x,[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">color</span>=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">np</span>.<span class="built_in">array</span>([i==-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]):</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="built_in">color</span>.<span class="built_in">append</span>(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">color</span>.<span class="built_in">append</span>(<span class="number">0</span>)</span><br><span class="line">    plt.scatter(x1,x2,c=<span class="built_in">color</span>)</span><br><span class="line">    xx,yy=f(w,b)</span><br><span class="line">    plt.plot(xx,yy)</span><br><span class="line">    plt.<span class="built_in">xlabel</span>(<span class="string">"x0"</span>)</span><br><span class="line">    plt.<span class="built_in">ylabel</span>(<span class="string">"x1"</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    plt.ylim(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    plt.<span class="built_in">title</span>(<span class="string">"Realization of perceptron"</span>)</span><br><span class="line">    plt.<span class="built_in">show</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == '__main__':</span><br><span class="line">    t_w=<span class="built_in">np</span>.<span class="built_in">array</span>([<span class="number">3</span>,-<span class="number">2</span>])    #学习方便，仅设计两个参数，两个特征值</span><br><span class="line">    t_b=<span class="number">4.3</span>                 #生成值的b</span><br><span class="line">    num_size=<span class="number">80</span>             #创造的训练数据量</span><br><span class="line">    learning_rate=<span class="number">0.1</span></span><br><span class="line">    x,y=createData(t_w,t_b,num_size)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"train data"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"&#123;&#125;*w0+&#123;&#125;*w1+b &gt;= 0? &#123;&#125;"</span>.format(x[i][<span class="number">0</span>],x[i][<span class="number">1</span>],y[i]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"Answer"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    w,b=train(x,y,learning_rate)</span><br><span class="line">    <span class="built_in">show</span>(x,y,w,b)</span><br></pre></td></tr></table></figure></p><h4 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h4><p><img src="/2018/10/10/感知机的原理及实现/Figure_1.png" alt="感知机学习算法的原始形式的结果图"><br><img src="/2018/10/10/感知机的原理及实现/QQ20181016-090136.png" alt="感知机学习算法的原始形式的预测性能与结果"></p><h3 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h3><blockquote><p>输入：线性可分的数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中$x_i \in R^n$，$x_i \in R^n,y_i \in \{-1,+1\},i=1,2,…,N$，$学习率\eta(0&lt;\eta\le 1)$<br>输出：$\alpha,b$；感知机模型$f(x)=sign(\sum_{j=1}^{N}\alpha_j y_j x_j+b)$，其中$\alpha = (\alpha_1,\alpha_2,…,\alpha_N)^T.$</p><ol><li>$\alpha\gets 0,b\gets 0$</li><li>在训练集中选取数据$(x_i,y_i)$</li><li>如果$y_i\lgroup\sum_{j=1} ^N{\alpha_j y_j x_i +b}\rgroup\le 0$ $$\alpha_i \gets \alpha_i+\eta$$ $$b\gets b+\eta y_i$$</li><li>转至2直到没有误分类数据</li></ol><p>对偶形式中训练实例仅为内积的形式出现，为了方便，可以预先将训练集中实例的内积计算出来并用矩阵的形式存储，这个矩阵就是所谓的Gram矩阵$$G=[x_i\bullet x_j]_{N\times N}$$</p></blockquote><h3 id="感知机学习算法的对偶形式的实现"><a href="#感知机学习算法的对偶形式的实现" class="headerlink" title="感知机学习算法的对偶形式的实现"></a>感知机学习算法的对偶形式的实现</h3><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>与原始形式不同的地方在于实例中的内积是通过求解Gram矩阵获得，详细代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author   : yechenchen</span></span><br><span class="line"><span class="comment"># @Time     : 2018/10/9 下午5:19</span></span><br><span class="line"><span class="comment"># @File     : 感知机学习算法的对偶形式.py</span></span><br><span class="line"><span class="comment"># @Software : PyCharm Community Edition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#感知机学习算法的对偶形式，P33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">np.random.seed(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateData</span><span class="params">(h_size,w_size)</span>:</span></span><br><span class="line">    x=np.random.rand(h_size,w_size)</span><br><span class="line">    <span class="keyword">return</span> (x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#给予对应的真实值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY</span><span class="params">(X,feature_num)</span>:</span></span><br><span class="line">    w=np.random.rand(feature_num)</span><br><span class="line">    b=<span class="number">-0.2</span></span><br><span class="line">    print(w,b)</span><br><span class="line">    Y=np.array([])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> X:</span><br><span class="line">        <span class="keyword">if</span> np.dot(w,i)+b&gt;<span class="number">0</span>:</span><br><span class="line">            Y=np.append(Y,[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Y=np.append(Y,[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建Gram矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getG</span><span class="params">(X)</span>:</span></span><br><span class="line">    G=np.zeros((len(X),len(X)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(len(X)):</span><br><span class="line">            G[i][t]=np.dot(X[i],X[t])</span><br><span class="line">    <span class="keyword">return</span> G</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练过程，默认学习率为0.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(X,Y,G,feature_num,learning_rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    a=np.zeros(len(Y))</span><br><span class="line">    b=<span class="number">0</span></span><br><span class="line">    finish_flag=<span class="keyword">False</span></span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> finish_flag:</span><br><span class="line">        finish_flag=<span class="keyword">True</span></span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">        f_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(G)):</span><br><span class="line">            tmp=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(Y)):</span><br><span class="line">                tmp+=(a[j]*Y[j]*G[i][j])</span><br><span class="line">            ans=Y[i]*(tmp+b)</span><br><span class="line">            <span class="keyword">if</span> ans&lt;=<span class="number">0</span>:</span><br><span class="line">                a[i]+=<span class="number">1</span>*learning_rate   <span class="comment">#更新a值</span></span><br><span class="line">                b+=Y[i]*learning_rate   <span class="comment">#更新b值</span></span><br><span class="line">                finish_flag=<span class="keyword">False</span></span><br><span class="line">                f_num+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"Traversing the &#123;&#125; times , b= &#123;:.2f&#125; accuracy= &#123;:.2f&#125;."</span>.format(num,b,(len(Y)-f_num)/len(Y)))</span><br><span class="line">    w=np.zeros(feature_num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        w+=a[i]*X[i]*Y[i]</span><br><span class="line">    <span class="keyword">return</span> w,b</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建预测到的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w,b)</span>:</span></span><br><span class="line">    x0 = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> x0,[-(w[<span class="number">0</span>]*i+b)/w[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x0]</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化显示得到的函数以及散点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(x,y,w,b)</span>:</span></span><br><span class="line">    x1=np.dot(x,[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">    x2=np.dot(x,[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    color=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.array([i==<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]):</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            color.append(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            color.append(<span class="number">0</span>)</span><br><span class="line">    plt.scatter(x1,x2,c=color)</span><br><span class="line">    xx,yy=f(w,b)</span><br><span class="line">    plt.plot(xx,yy)</span><br><span class="line">    plt.xlabel(<span class="string">"x0"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"x1"</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.title(<span class="string">"Realization of perceptron"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    feature_num=<span class="number">2</span>   <span class="comment">#每个样本具备的特征值的数量，设为2时可以可视化输出，否则需要用PCA降维</span></span><br><span class="line">    data_size=<span class="number">80</span>    <span class="comment">#训练数据量</span></span><br><span class="line">    X=CreateData(data_size,feature_num)    <span class="comment">#每组数据五个特征值，共80组数据</span></span><br><span class="line">    Y=getY(X,feature_num)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"train data"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(data_size):</span><br><span class="line">        print(X[i],Y[i])</span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">10</span>, <span class="string">"train"</span>, <span class="string">"*"</span> * <span class="number">10</span>)</span><br><span class="line">    G=getG(X)</span><br><span class="line">    w,b=train(X,Y,G,feature_num)</span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">10</span>, <span class="string">"ans"</span>, <span class="string">"*"</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"w=&#123;&#125;,b=&#123;&#125;"</span>.format(w,b))</span><br><span class="line">    show(X,Y,w,b)</span><br></pre></td></tr></table></figure></p><h4 id="实现结果-1"><a href="#实现结果-1" class="headerlink" title="实现结果"></a>实现结果</h4><p><img src="/2018/10/10/感知机的原理及实现/Figure_2.png" alt="感知机学习算法的对偶形式的结果图"><br><img src="/2018/10/10/感知机的原理及实现/QQ20181016-092327.png" alt="感知机学习算法的原始形式的预测性能与结果"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> python </tag>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《统计学习方法》概论整理</title>
      <link href="/2018/10/04/2018-10-04-%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%A6%82%E8%AE%BA%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/04/2018-10-04-%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%A6%82%E8%AE%BA%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在导师的推荐下，本人开始阅读李航博士的<code>《统计学习方法》</code>，该书是以内容短小精悍著称，因此我也从此书开始正式进入了机器学习的学习阶段。当然在这一节中，本人只是对该章节知识点进行梳理，由于多是基本知识点，所以量很大，内容也很多。</p><h2 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h2><h3 id="统计学习的概念"><a href="#统计学习的概念" class="headerlink" title="统计学习的概念"></a>统计学习的概念</h3><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行<code>预测与分析</code>的一门学科，统计学习也称为统计机器学习。<br></p><h3 id="统计学习的对象"><a href="#统计学习的对象" class="headerlink" title="统计学习的对象"></a>统计学习的对象</h3><p>统计学习的对象是<code>数据</code>，它从数据出发，提取数据的特征，抽象出数据的模型，从数据中发现知识，又回到对数据的分析与预测中去。</p><h3 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h3><p>统计学习由监督学习(supervised learning)、非监督学习(unsupervised learning)、半监督学习(semi-supervised learning)、强化学习(reinforcement learning)等组成。</p><h3 id="统计学习中的常用概念"><a href="#统计学习中的常用概念" class="headerlink" title="统计学习中的常用概念"></a>统计学习中的常用概念</h3><ul><li>我们认为要学习的模型属于某个函数的集合，该集合被称为<code>假设空间</code>。<br></li><li>训练数据、测试数据：意如其名。<br></li><li>统计学习方法的三要素为<code>模型(model)</code>、<code>策略(strategy)</code>、<code>算法(algorithm)</code>。</li></ul><h3 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h3><blockquote><p>(1) 得到一个有限的训练数据集合；<br><br>(2) 确定包含所有可能的模型的假设空间，即学习的模型的集合；<br><br>(3) 确定模型选择的准则，即学习的策略；<br><br>(4) 实现求解最优模型的算法，即学习的算法；<br><br>(5) 通过学习方法选择最优模型；<br><br>(6) 利用学习的最优模型对新数据进行预测或分析；</p></blockquote><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="监督学习的概念"><a href="#监督学习的概念" class="headerlink" title="监督学习的概念"></a>监督学习的概念</h3><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同）<br></p><p>本人认为，”<code>这里的输入、输出</code>“指的不是特征值，而仅仅只是指代系统需要输入输出样本。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>输入空间、特征空间与输出空间</strong><br><br>首先，输入空间与输出空间指的是输入输出所有的可能取值的集合。输入与输出空间可以是有限元素的集合，也可以是整个欧式空间，两者可以是指同一个空间，也可以是不同的空间，通常情况下，输出空间远远小于输入空间。<br><br>每个具体的输入是一个实例，通常由特征向量来表示，此时所有的特征向量存在的空间称为特征空间。特征空间的每一维对应于一个特征。</li><li><strong>联合概率分布</strong><br><br>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X,Y)，P(X,Y)表示分布函数，或者称分布密度函数。</li><li><strong>假设空间</strong><br><br>模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定。</li></ul><h2 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h2><p>$$方法=模型+策略+算法$$</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在监督学习中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。<br><br>假设空间用$\mathcal{F}$表示，假设空间可以定义为决策函数的集合：<br></p><p>$$ \mathcal{F}=\{f|Y=f(X)\} $$</p><p>其中，X和Y是定义在输入空间$\mathcal{X}$和输出空间$\mathcal{Y}$上的变量，这时$\mathcal{F}$通常是由一个参数向量决定的函数族：<br></p><p>$$\mathcal{F}=\{ f|Y=f_\theta(X),\theta\in R^n \}$$</p><p>参数向量$\theta$取值与n维欧式空间$R^n$，称为参数空间。<br></p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>统计学习的<code>目标</code>在于从假设空间中选取<strong>最优模型</strong>。首先需要引入损失函数与风险函数的概念，损失函数度量模型<code>一次预测</code>的好坏，风险函数度量<code>平均意义下</code>的模型预测的好坏。两者的区别就在于一次预测和平均意义。</p><h4 id="损失函数和风险函数（重要）"><a href="#损失函数和风险函数（重要）" class="headerlink" title="损失函数和风险函数（重要）"></a><strong>损失函数和风险函数（重要）</strong></h4><p>监督学习问题是在假设空间$\mathcal{F}$中选取模型$f$作为决策函数，对于给定的输入$X$,由$f(X)$给出相应的输出$Y$，这个输出的预测值$f(X)$与真实值$Y$可能一致也可能不一致，因此需要一个损失函数(loss function)或代价函数(cost function)来度量预测错误的程度，损失函数是$f(X)$和$Y$的非负实值函数，记作为$L(Y,f(X))$.<br>统计学习常用的损失函数有以下几种：</p><ul><li><p>0-1损失函数（0-1 loss function）<br></p><p>  $$L(Y,f(x))=\begin{cases}<br>  1,&amp; Y \ne f(X)\\<br>  0,&amp; Y = f(X)<br>  \end{cases}$$</p></li><li><p>平方损失函数（quadratic loss function）</p><p>$$L(Y,f(X))=(Y-f(X))^2$$</p></li><li><p>绝对损失函数（absolute loss function）</p><p>$$L(Y,f(X))=|Y-f(X)|$$</p></li><li><p>对数损失函数（logarithmic loss function）或对数似然损失函数（log-likelihood loss function）</p><p>$$L(Y,P(Y|X))=-log(P(Y|X))$$</p></li></ul><p>损失函数值越小，模型就越好，由于模型的输入、输出是随机变量，遵循联合分布$P(X,Y)$所以损失函数的期望是:<br></p><p>$$R_{exp}(f)=E_p[L(Y,f(X))]= \lmoustache_{x \times y}L(y,f(x))P(x,y)dxdy$$</p><p>这就是理论上模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失，称为风险函数或期望损失。<br>由于联合分布是未知的，因此$R_exp(f)$不能直接计算，如果知道了联合分布那也就不需要学习了，一方面根据期望风险最小来学习模型要用到联合分布，而联合分布却是未知的，因此我们需要引入一个<code>经验风险</code>的概念，其实模型f(x)关于训练数据集的平均损失，记作$R_{emp}$</p><p>$$R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))   \qquad$$</p><p>注：上式子中，N代表着训练集中的样本数量</p><h4 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a><strong>经验风险最小化与结构风险最小化</strong></h4><p>在经验风险最小化的策略中，我们需要的是求解上述经验风险的最小化，就是求解最优化问题：<br></p><p>$$min_{f\in \mathcal{F}}  \frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))\qquad$$</p><p>当样本容量足够大的时候，经验风险最小化有着很好的效果，因此被广泛采用。<br>当样本容量很小的时候，经验风险最小化学习的效果就未必很好，可能还会有过拟合的情况发生。结构风险最小化就是为了防止过拟合而提出来的策略，结构风险最小化等价于<strong>正则化</strong>，结构风险是在经验风险上加了表示模型复杂度的正则化项（或者称为罚项），在假设空间、损失函数、训练数据集确定的时候，<strong>结构风险</strong>的定义是</p><p>$$R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><ul><li>$J(f)$为模型的复杂度，是定义在假设空间$\mathcal{F}$上的反函数，模型$f$越复杂，复杂度$J(f)$就越大。</li><li>$\lambda$是系数，泳衣权衡经验风险和模型复杂度。</li></ul><p>结构风险最小化策略认为结构风险最小的模型是最优的模型，所以最优模型，就是求解最优化的问题:<br></p><p>$$min_{f\in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><p>在这时，监督学习问题就变成了经验风险或结构风险函数的最优化问题。</p><h4 id="公式整理"><a href="#公式整理" class="headerlink" title="公式整理"></a><strong>公式整理</strong></h4><table><thead><tr><th>风险名称</th><th>损失函数</th><th>最优化</th></tr></thead><tbody><tr><td>期望风险</td><td>$R_{exp}(f)=E_p[L(Y,f(X))]= \lmoustache_{x \times y}L(y,f(x))P(x,y)dxdy$</td><td>不可求</td></tr><tr><td>经验风险</td><td>$ R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))   \qquad $</td><td>$min_{f\in \mathcal{F}}R_{emp}(f)  $</td></tr><tr><td>结构风险</td><td>$R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$</td><td>$min_{f\in \mathcal{F}}R_{srm}(f)  $</td></tr></tbody></table><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是指学习模型的具体计算方法。按照以上所讲，统计学习问题归结为最优化问题，统计学习的算法称为求解最优化问题的算法，通过数值计算的方法求解，来保证找到全局最优解。</p><p>统计学习方法之间的不同，主要来自其模型、策略、算法的不同，若三者确定，统计学习的方法也就随之确定，因此称其为统计学习的三要素。</p><h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h3><p>当损失函数给定时，基于损失函数的模型的训练误差和模型的测试误差就自然成为学习方法评估的标准，注意，统计学习方法具体采用的损失函数未必是评估时使用的损失函数，当然，让两者一致是比较理想的。</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>如果一味地追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种情况呗称为过拟合。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但是对未知数据预测得很差的现象。</p><h2 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h2><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化是结构风险最小化策略的实现，是在经验风险上加上正则化项和罚项。正则化项一般是模型复杂度的<code>单调递增函数</code>，也就是模型越复杂，正则化值越大，LOSS值也就越大。</p><p>正则化的一般形式：</p><p>$$min_{f\in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$</p><p>正则化项有着不同的形式，一般是与参数向量有关，经常使用范数来表示。</p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>这里就需要引入一个范数的概念了。</p><p>L0范数：实际上表示的为向量中非零元素的个数</p><p>$$L0(x)= ^0 \sqrt{\sum_{i=1}^n|x_i|^0}$$</p><ul><li>L1范数：又被称为曼哈顿距离、最小绝对误差等</li></ul><p>$$L1(X)=\sum_{i=1}^n|x_i|$$</p><ul><li>L2范数：又被称为欧式距离，是用的最多的距离度量</li></ul><p>$$L2(X)=\sqrt{\sum_{i=1}^n|x_i|^2}$$</p><p>范数在numpy中有具体的实现方法：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下列语句可以实现求解a向量与b向量之间的距离</span></span><br><span class="line">np.linalg.norm(<span class="keyword">a</span>-b)</span><br></pre></td></tr></table></figure></p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>生成方法是由数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布$P(X|Y)$作为预测的模型。这就是生成模型：</p><p>$$P(X|Y)=\frac{P(X,Y)}{P(X)}$$</p><p>该方法之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。</p><h3 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h3><p>判别方法是数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别模型关心的是对给定的输入，应该预测什么样的输出。</p><h3 id="生成方法和判别方法的特点比较"><a href="#生成方法和判别方法的特点比较" class="headerlink" title="生成方法和判别方法的特点比较"></a>生成方法和判别方法的特点比较</h3><p>生成方法的特点：</p><ul><li>生成方法可以还原出联合概率分布$P(X,Y)$，而判别方法不能；</li><li>生成方法的学习收敛速度更快，模型可以更快地收敛于真实模型</li><li>当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。</li></ul><p>判别方法的特点：</p><ul><li>判别方法直接学习的是条件概率$P(Y|X)$或决策函数$f(X)$</li><li>直接面对预测，往往学习的准确率更高。</li><li>由于直接学习$P(Y|X)或$f(X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</li></ul><h2 id="针对分类问题的指标（重要）"><a href="#针对分类问题的指标（重要）" class="headerlink" title="针对分类问题的指标（重要）"></a>针对分类问题的指标（重要）</h2><p>对二分类问题常用的评价指标是精准率和召回率。通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4中情况出现的总数分别记作：</p><ul><li>TP——将正类预测为正类的数量</li><li>FN——将正类预测为负类的数量</li><li>FP——将负类预测为正类的数量</li><li>TN——将负类预测为负类的数量</li></ul><p>精准率的定义为$P=\frac{TP}{TP+FP}$，可以记为判断为正类的样本中的真实正类的比重。</p><p>召回率的定义为$R=\frac{TP}{TP+FN}$，可以记为真实的正类被判定为正类的比重。</p><p>$F_1$值，是精确率和召回率的调和均值，即$\frac{2}{F_1}=\frac{1}{P}\frac{1}{R}$，$F_1=\frac{2TP}{2TP+FP+FN}$，因此可以看出，当精准率和召回率都高的时候，$F1$值才会高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节主要讲的都是统计学习中的一些基本概念，这份整理也花了不少的时间，应该理解深刻。从下一章开始，进入了十个算法的学习，并且每章都会在理论的基础上配上代码实现，尽请期待了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络实践课程设计——五子棋</title>
      <link href="/2018/09/18/2018-09-18-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/18/2018-09-18-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="游戏形式"><a href="#游戏形式" class="headerlink" title="游戏形式"></a>游戏形式</h2><p>本游戏是通过socket来进行五子棋游戏，我们的形式是<code>一台server</code>开启之后可以支持尽可能多的<code>客户端</code>运行。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li><p><code>server</code></p><ul><li><code>net</code>：socket通信相关功能<ul><li>Action:解析socket传来的指令后进行的执行操作</li><li>EndDeal:游戏结束后的相关处理</li><li>Resolve：对收到的指令（字符串）进行解析处理</li><li>ServerThread：针对多个客户端，开启多个线程支持</li></ul></li><li><code>tool</code><ul><li>FightManager：下棋对战时的相关信息</li><li>HashMapManager：存储对战时配对上的map组合</li><li>MessageManager：用于进行消息管理，包括信息的发送等等</li><li>Player：存储玩家的个人信息</li><li><code>check</code>:进行游戏状态的检测<ul><li>check:检测胜负</li><li>checkX&amp;Y:横纵检测状态</li><li>checkM&amp;N:斜着检测状态</li></ul></li></ul></li><li><code>ui</code>：ui界面<ul><li>ClientPanel:客户端列表版面</li><li>MatchsPanel：配对连接版面</li><li>MessagePanel：消息显示版面</li><li>ServerFrame：服务器主窗口</li></ul></li><li>Server.java:主程序</li></ul></li><li><p><code>client</code></p><ul><li><code>data</code><ul><li>Data:存储玩家自己的相关信息，包括ID、昵称、配对对象等等</li></ul></li><li><code>image</code>：相关的图片，用于表示棋子等</li><li><code>listener</code>：用于监听相关的操作<ul><li>BackListener：悔棋操作</li><li>ChallengeListener：挑战操作</li><li>ConnectListener：登录操作</li><li>ListListener：列表双击操作</li><li>MapListener：监听棋盘</li><li>MessageListener：监听消息发送</li><li>NameListener：重命名操作</li><li>QuitListener：退出操作</li><li>RestartListener：重新开始操作</li><li>StartListener：游戏开始</li></ul></li><li><code>manager</code><ul><li>IOManager:输入输出流</li><li>ListManager:管理玩家列表</li><li>MessageManager：管理消息</li></ul></li><li><code>net</code><ul><li>Connect：登录服务器</li><li>PlayChess：游戏落字传输</li><li>Receive：接收数据线程</li><li>Resolve：解析数据</li></ul></li><li><code>ui</code><ul><li>ChessBoardCanvas：棋盘画板</li><li>FunctionPanel：功能区</li><li>GameFrame：游戏主界面</li><li>GamePanel：左边游戏区</li><li>MessagePanel：消息面板</li><li>OperationPanel：操作面板</li><li>PlayerPanel：玩家面板</li></ul></li><li>QuinterGame：客户端启动</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课设记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jekyll框架搭建</title>
      <link href="/2018/09/16/2018-09-16-MAC_OSX%E4%B8%8A%E5%AE%89%E8%A3%85jekyll/"/>
      <url>/2018/09/16/2018-09-16-MAC_OSX%E4%B8%8A%E5%AE%89%E8%A3%85jekyll/</url>
      
        <content type="html"><![CDATA[<p>1.安装ruby(mac上自带，此步可以跳过)</p><p>2.安装jekyll</p><ul><li><p>安装jekyll</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> jekyll</span><br></pre></td></tr></table></figure></li><li><p>顺利地安装完成之后，可以生成自己的一个博客</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jekyll <span class="keyword">new</span> myBlog</span><br></pre></td></tr></table></figure></li><li><p>接下来尝试进入博客运行一下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myBlog</span><br><span class="line">jekyll <span class="keyword">server</span></span><br></pre></td></tr></table></figure></li><li><p>hin难受，果然报了个错！！！错误输出如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Ruby.framework<span class="regexp">/Versions/</span><span class="number">2.3</span><span class="regexp">/usr/</span>lib<span class="regexp">/ruby/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/rubygems/</span>core_ext/kernel_require.<span class="string">rb:</span><span class="number">55</span>:<span class="keyword">in</span> <span class="string">'require'</span>: cannot load such file -- bundler (LoadError)</span><br><span class="line">from <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Ruby.framework<span class="regexp">/Versions/</span><span class="number">2.3</span><span class="regexp">/usr/</span>lib<span class="regexp">/ruby/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/rubygems/</span>core_ext/kernel_require.<span class="string">rb:</span><span class="number">55</span>:<span class="keyword">in</span> <span class="string">'require'</span></span><br><span class="line">from <span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/gems/</span>jekyll<span class="number">-3.8</span><span class="number">.3</span><span class="regexp">/lib/</span>jekyll/plugin_manager.<span class="string">rb:</span><span class="number">48</span>:<span class="keyword">in</span> <span class="string">'require_from_bundler'</span></span><br><span class="line">from <span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.3</span><span class="number">.0</span><span class="regexp">/gems/</span>jekyll<span class="number">-3.8</span><span class="number">.3</span><span class="regexp">/exe/</span><span class="string">jekyll:</span><span class="number">11</span>:<span class="keyword">in</span> <span class="string">'&lt;top (required)&gt;'</span></span><br><span class="line">from <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span><span class="string">jekyll:</span><span class="number">22</span>:<span class="keyword">in</span> <span class="string">'load'</span></span><br><span class="line">from <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span><span class="string">jekyll:</span><span class="number">22</span>:<span class="keyword">in</span> <span class="string">'&lt;main&gt;'</span></span><br></pre></td></tr></table></figure></li><li><p>接下来就是上网找了找如何解决该问题，因为笔者也是小白，第一次搭博客，所幸找到了解决方案，感激！解决办法如下：</p></li><li><p>安装bundle</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install </span><span class="keyword">bundle</span></span><br><span class="line"><span class="keyword">gem </span><span class="keyword">install </span>minima</span><br><span class="line">gem <span class="keyword">install </span><span class="keyword">jekyll-feed</span></span><br></pre></td></tr></table></figure></li><li><p>本以为完成了，就开心的开启了一下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>exec <span class="keyword">jekyll </span>serve</span><br></pre></td></tr></table></figure></li><li><p>但是！但是！但是！它又报了一个错！</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could <span class="keyword">not</span> <span class="builtin-name">find</span> public_suffix-3.0.0 <span class="keyword">in</span> any of the sources</span><br><span class="line"><span class="builtin-name">Run</span> `bundle install` <span class="keyword">to</span> install missing gems.</span><br></pre></td></tr></table></figure></li><li><p>好的是，只要我们认真听话的执行一下提示代码就可以了！</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>install</span><br></pre></td></tr></table></figure></li><li><p>然后等待全部安装完成</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Bundle complete! <span class="number">4</span> Gemfile dependencies, <span class="number">23</span> gems now installed.</span><br><span class="line">Use `bundle info [gemname]` to see <span class="keyword">where</span> a bundled gem is installed.</span><br></pre></td></tr></table></figure></li><li><p>最后启动！</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>exec <span class="keyword">jekyll </span>serve</span><br></pre></td></tr></table></figure></li><li><p>然后打开<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> ，就能完美的看到自己的博客啦，jekyll就已经安装完成咯。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jekyll </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018华为秋招笔试</title>
      <link href="/2018/08/30/2018%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
      <url>/2018/08/30/2018%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>徘徊在保研与不保研之间，看了考研书感觉自己根本看不下去，看实验室同学都去了华为，因此就像报名了华为的秋招，报名了大数据开发岗，<del>由于之前参加比赛学过hadoop等大数据框架</del>，所以报了试试看，前几天通知了笔试，于是就去水了一波。</p><h2 id="笔试介绍"><a href="#笔试介绍" class="headerlink" title="笔试介绍"></a>笔试介绍</h2><p>华为今年的笔试和去年形式差不多，三道编程题，分值分别是100、200、300，语言基本上都可以使用，题目自我感觉很简单，因为都是一遍AC了，一个小时就解决了，hhh，就不吹了，下面记录记录题目和我的代码。</p><h3 id="字符串处理题"><a href="#字符串处理题" class="headerlink" title="字符串处理题"></a>字符串处理题</h3><p>题目是从一个字符串中找到所有存在的整数，包括负号，且负号可累计，然后将寻找到的整数相加即可，下面是代码：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">import sys</span><br><span class="line">numlist= [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">10</span>))]</span><br><span class="line"><span class="comment"># print(numlist)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> sys.<span class="keyword">stdin</span>:</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">line</span>.<span class="built_in">split</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">a</span>:</span><br><span class="line">        flag=True<span class="comment">#当前数字为正</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span><span class="comment">#当前和</span></span><br><span class="line">        <span class="built_in">num</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">char</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">char</span> == <span class="string">'-'</span>:</span><br><span class="line">                flag=<span class="keyword">not</span> flag</span><br><span class="line">            elif <span class="keyword">char</span> <span class="keyword">in</span> numlist:</span><br><span class="line">                <span class="comment">#数字处理</span></span><br><span class="line">                    <span class="built_in">num</span>=<span class="built_in">num</span>*<span class="number">10</span>+int(<span class="keyword">char</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="built_in">sum</span>+=<span class="built_in">num</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">sum</span>-=<span class="built_in">num</span></span><br><span class="line">                <span class="comment"># sum+=num</span></span><br><span class="line">                <span class="comment"># print(sum)</span></span><br><span class="line">                <span class="built_in">num</span>=<span class="number">0</span></span><br><span class="line">                flag=True</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">sum</span>+=<span class="built_in">num</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">sum</span>-=<span class="built_in">num</span></span><br><span class="line">        print(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure></p><h3 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h3><p>题目是需要按照给定的规则，来计算带有复数的卷积，卷积定义网上也有，我就不赘述了，直接开模拟，代码如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">import sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fuNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x,y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.r=x</span><br><span class="line">        <span class="keyword">self</span>.im=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r + b.r, <span class="keyword">self</span>.im + b.im)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r - b.r, <span class="keyword">self</span>.im - b.im)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mult</span><span class="params">(<span class="keyword">self</span>,b)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> fuNum(<span class="keyword">self</span>.r * b.r - <span class="keyword">self</span>.im * b.im, b.r * <span class="keyword">self</span>.im + <span class="keyword">self</span>.r * b.im)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">"__main__"</span><span class="symbol">:</span></span><br><span class="line">    duoa=[]</span><br><span class="line">    duob=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 读取每一行</span></span><br><span class="line">        r = eval(sys.stdin.readline().strip())</span><br><span class="line">        im= eval(sys.stdin.readline().strip())</span><br><span class="line">        duoa.append(fuNum(r,im))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 读取每一行</span></span><br><span class="line">        r = eval(sys.stdin.readline().strip())</span><br><span class="line">        im= eval(sys.stdin.readline().strip())</span><br><span class="line">        duob.append(fuNum(r,im))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)<span class="symbol">:</span></span><br><span class="line">        duoa.append(fuNum(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        duob.append(fuNum(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># n=4</span></span><br><span class="line">    duoc=[]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">9</span>)<span class="symbol">:</span></span><br><span class="line">        temp=fuNum(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">            <span class="comment"># print(k,n)</span></span><br><span class="line">            temp=temp.add(duoa[k].mult(duob[n-k]))</span><br><span class="line">        <span class="comment"># print(temp.r,temp.im)</span></span><br><span class="line">        duoc.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(duoc)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="symbol">duoc:</span></span><br><span class="line">        print(i.r)</span><br><span class="line">        print(i.im)</span><br></pre></td></tr></table></figure></p><h3 id="牛生小牛的问题"><a href="#牛生小牛的问题" class="headerlink" title="牛生小牛的问题"></a>牛生小牛的问题</h3><p>传说中300分的题目，题目具体数据记不清了，是牛生小牛的问题，不过好像和经典例题的递归形式不同，这题我在思考的时候加上了dp的思想，<del>因为用递归模拟，发现过不了样例</del>，代码如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 读取第一行的n</span></span><br><span class="line">    n = <span class="built_in">int</span>(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 每一个例子</span></span><br><span class="line">        M = eval(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line">        N = eval(sys.<span class="literal">stdin</span>.readline().strip())</span><br><span class="line">        cheng=[M,M,M,M,M]</span><br><span class="line">        wei=[<span class="number">0</span>,M,<span class="number">2</span>*M,<span class="number">3</span>*M,<span class="number">4</span>*M]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,N+<span class="number">1</span>):</span><br><span class="line">            cheng.append(cheng[i-<span class="number">1</span>]+(wei[i-<span class="number">3</span>]-wei[i-<span class="number">4</span>]))</span><br><span class="line">            wei.append(wei[i-<span class="number">1</span>]+cheng[i]-(wei[i-<span class="number">3</span>]-wei[i-<span class="number">4</span>]))</span><br><span class="line">            <span class="comment"># print(i,cheng[i],wei[i])</span></span><br><span class="line">        print(cheng[N]+wei[N])</span><br></pre></td></tr></table></figure></p><p>就这样三道题目就全部AC了，难度不是太大，感觉打过ACM的全AC是很正常的事情，所以对ACMer菊厂也是相当欢迎的。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>九月初拿到学校保研资格的那天，放弃了菊厂的面试，菊厂打了好几个电话来问，给人的感觉是相当负责的，当时和他们说等我研究生毕业再去菊厂了，哈哈哈，又装了13，溜了溜了看书了。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python实践——塔防游戏</title>
      <link href="/2018/07/20/python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/07/20/python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这仅仅只是一个入门级游戏，一个小toy，使用的也就是贴图形式的pygame，因为需要过多的访存次数，图片的精度也较高，所以对内存以及硬盘的速度有着较高的要求。<del>当时答辩的辣鸡主机上，我们跑的就相当卡。</del></p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>语言版本：python 3.6.2<br><br>依赖：pygame<br><br>系统：皆可<br></p><h2 id="游戏按键"><a href="#游戏按键" class="headerlink" title="游戏按键"></a>游戏按键</h2><p>暂停/开始：Space<br><br>退出：Esc<br></p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="/2018/07/20/python实践——塔防游戏/开始界面.png" alt="游戏开成动画" title="游戏开成动画"><br><img src="/2018/07/20/python实践——塔防游戏/游戏截图.png" alt="游戏中截图" title="游戏截图"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><a href="https://github.com/netycc/Tower-defense-game" title="塔防游戏" target="_blank" rel="noopener">https://github.com/netycc/Tower-defense-game</a></p>]]></content>
      
      
      <categories>
          
          <category> 课设记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="用于日常笔记"><meta name="baidu-site-verification" content="31u13chEy5"><title>决策树的原理及实现 | Netycc's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '83d60cd5e215de54f53db5b26853c623';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">决策树的原理及实现</h1><a id="logo" href="/.">Netycc's blog</a><p class="description">每天进步一点点，吃吃喝喝的single dog.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline"><i class="fa fa-history"> 时间线</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">决策树的原理及实现</h1><div class="post-meta">Oct 19, 2018<span> | </span><span class="category"><a href="/categories/学习笔记/">学习笔记</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 18</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2018/10/19/决策树的原理及实现/#vcomment"><span class="valine-comment-count" data-xid="/2018/10/19/决策树的原理及实现/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#决策树模型与学习"><span class="toc-number">2.</span> <span class="toc-text">决策树模型与学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#决策树模型"><span class="toc-number">2.1.</span> <span class="toc-text">决策树模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#决策树与if-then规则"><span class="toc-number">2.2.</span> <span class="toc-text">决策树与if-then规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#决策树与条件概率分布"><span class="toc-number">2.3.</span> <span class="toc-text">决策树与条件概率分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#决策树学习"><span class="toc-number">2.4.</span> <span class="toc-text">决策树学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特征选择"><span class="toc-number">3.</span> <span class="toc-text">特征选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特征选择问题"><span class="toc-number">3.1.</span> <span class="toc-text">特征选择问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信息增益"><span class="toc-number">3.2.</span> <span class="toc-text">信息增益</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#信息增益算法的实现"><span class="toc-number">3.2.1.</span> <span class="toc-text">信息增益算法的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信息增益比"><span class="toc-number">3.3.</span> <span class="toc-text">信息增益比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#决策树的生成"><span class="toc-number">4.</span> <span class="toc-text">决策树的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ID3算法"><span class="toc-number">4.1.</span> <span class="toc-text">ID3算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C4-5的生成算法"><span class="toc-number">4.2.</span> <span class="toc-text">C4.5的生成算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#决策树的剪枝"><span class="toc-number">5.</span> <span class="toc-text">决策树的剪枝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#剪枝所用的损失函数"><span class="toc-number">5.1.</span> <span class="toc-text">剪枝所用的损失函数</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，相对于前面几章，决策树的新鲜知识点明显要多了，引入了很多<em>信息论</em>中的内容，<del>看的很难受呀</del>，不过在信念的坚持下，还是开始总结了本章的知识点。</p>
<p>决策树是一种基本的分类与回归方法。本篇文章主要讨论分类的决策树，决策树呈现树形结构，在分类问题中，表示基于特征对实例进行分类的过程。它可以被认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。主要优点是<em>模型具有可读型、分类速度快</em>，学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据利用决策树模型进行分类，决策树学习通常包括3个步骤：<em>特征选择、决策树的生成和决策树的修剪</em>。</p>
<h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><blockquote>
<p>定义5.1（决策树） 分类决策树模型是一种描述对实例进行分类的树形结构，决策树由结点（node）和有向边（directed edge）组成。结点有两种类型，内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。<br>用决策树分类，从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值，如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。</p>
</blockquote>
<h3 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h3><p>可以将决策树看成一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树有着<em>互斥并且完备</em>这一特点。就是说，每一个实例都被一条路径或一条规则所覆盖，并且只被一条路径或一条规则所覆盖。</p>
<h3 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义。这一条件概率分布定义在特征空间上的一个划分上。将特征空间划分为互不相交的单元或区域，并在每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的一条路径对应于划分中的一个单元，决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。假设X为表示特征的随机变量，Y为表示类的随机变量，那么这个条件概率分布可以表示为P(Y|X)。X取值于给定划分下单元的集合，Y取值于类的集合。各叶结点（单元）上的条件概率往往偏向某一个类，即属于某一类的概率较大。决策树分类时将该结点强行分到条件概率大的那一类去。</p>
<h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习，假设给定训练数据集$$D=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$$其中，$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T$为输入实例（特征向量），$n$为特征个数，$y_i\in \{1,2,…,K\}$为类标记，$i=1,2,…,N$，$N$为样本容量，学习的目标是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。<br>决策树学习本质上是从数据集中归纳出一组分类规则。与训练数据集不相矛盾的决策树可能有多个，也可能一个也没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛华能力。<br>当损失函数确定以后，学习问题就变为在损失函数意义下选择最优决策树的问题。因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树学习算法通常采用<em>启发式</em>方法，近似求解这一最优化问题。这样得到的决策树是次最优的。<br>决策树学习的算法通常是一个递归地选择最优特征，并根据特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。开始，构建根结点，将所有训练数据都放在根结点。选择一个最优特征，按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。如果这些子集已经能够被基本正确分类，那么构建叶结点，并将这些子集分到所对应的叶结点中去；如果还有子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行分割，构建相应的结点。如果递归地进行下去，直至所有训练数据集被基本正确分类，或者没有合适的特征为止，最后每个子集都被分到叶结点上，即都有了明确的类。这就生成了一课决策树。<br>以上方法生成的决策树可能对训练数据集有很好的分类能力，但对未知的测试数据却未必有很好的分类能力，即可能发生<em>过拟合</em>现象。我们需要对已生成的树自下向上而进行剪枝，将树变得更简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="特征选择问题"><a href="#特征选择问题" class="headerlink" title="特征选择问题"></a>特征选择问题</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的准则是<em>信息增益</em>或<em>信息增益比</em>。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>在信息论与概率统计中，熵（entropy）是表示随机变量不确定性的度量。设$X$是一个取有限个值的离散随机变量，其概率分布为$$P(X=x_i)=p_i  ,i=1,2,…,n$$则随机变量$X$的熵定义为$$H(X)=-\sum_{i=1}^{n}{p_i log p_i}$$在式中，若$p_i=0$，则定义$0log0=0$。通常，该式中的对数以2为底或以e为底（自然对数），这时熵的单元分别称作比特或纳特。由定义可知，<em>熵只依赖于X的分布</em>，而与X的取值无关，所以也可将X的熵记作$H(p)$，即$$H(p)=-\sum_{i=1}^{n}p_i log p_i$$</p>
<p>熵越大，随机变量的不确定性就越大，当$p=0$或$p=1$时$H(p)=0$，随机变量完全没有不确定性。当$p=0.5$时，$H(p)=1$，熵取值就最大，随机变量不确定性最大。</p>
<p>设有随机变量$(X,Y)$，其联合概率分布为$$P(X=x_i,Y=y_j)=p_{ij}，i=1,2,…,n;j=1,2,…,m$$条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量Y的不确定性。随机变量X给定的条件下随机变量Y的不确定性。随机变量X给定的条件下随机变量Y的条件熵$H(Y|X)$，定义为X给定条件下Y的条件概率分布的熵对X的数学期望$$H(Y|X)=\sum_{i=1}^{n}{p_iH(Y|X=x_i)}$$这里，$p_i=P(X=x_i),i=1,2,…,n.$</p>
<p>当熵和条件熵中的概率由数据估计得到时，所对应的熵和条件熵分别称为<em>经验熵</em>、<em>经验条件熵</em>。此时，如果有0概率，令$0log0=0$。<em>信息增益表示得知特征X的信息而使得类Y的信息的不确定性缺少的程度。</em></p>
<blockquote>
<p>定义5.2（信息增益）特征$A$对训练数据集D的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即$$g(D,A)=H(D)-H(D|A)$$一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为互信息。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
</blockquote>
<p>决策树学习应用信息增益准则选择特征。给定训练数据集D和特征A，经验熵$H(D)$表示对数据集$D$进行分类的不确定性。而经验条件熵$H(D|A)$表示在特征$A$给定的条件下对数据集D的不确定性。那么它们的差，即信息增益，就<strong>表示由于特征A而使得对数据集D的分类的不确定性减少的程度</strong>。显然，对于数据集D而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p>
<p>设训练数据为$D$，$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k$，$k=1,2,…,K$，$|C_k|$为属于类$C_k$的样本个数，$\sum_{k=1}^{K}{|C_k|=|D|}$。设特征$A$有$n$个不同的取值${a_1,a_2,…,a_n}$，根据特征A的取值将D划分为n个子集$D_1,D_2,…,D_n$，$|D_i|$为$D_i$的样本数量，$\sum_{i=1}^{n}{|D_i|=|D|}$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$，即$D_{ik}=D_i\cap C_k$，$D_{ik}$为$D_{ik}$的样本个数。于是信息增益的算法如下：</p>
<blockquote>
<p>算法5.1（信息增益的算法）<br>输入：训练数据$D$和特征$A$；<br>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$<br>(1)计算数据集D的经验熵$H(D)$$$H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|} log_2{\frac{C_k}{D}}}$$<br>(2)计算特征A对数据集D的经验条件熵$H(D|A)$$$H(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}H(D)}=-\sum_{i=1}^{n}{\frac{|D_{ik}|}{|D_i|}log_2\frac{|C_k|}{|D|}}$$<br>(3)计算信息熵$$g(D,A)=H(D)-H(D|A)$$</p>
</blockquote>
<h4 id="信息增益算法的实现"><a href="#信息增益算法的实现" class="headerlink" title="信息增益算法的实现"></a>信息增益算法的实现</h4><p>代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta"># 数据来源于P59页表5.1</span></span><br><span class="line"><span class="function">def <span class="title">get_data</span>(<span class="params"></span>):</span></span><br><span class="line"><span class="function">    dataSet </span>= [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],  <span class="meta"># 数据集</span></span><br><span class="line">               [<span class="meta">0, 0, 0, 1, 0</span>],</span><br><span class="line">               [<span class="meta">0, 1, 0, 1, 1</span>],</span><br><span class="line">               [<span class="meta">0, 1, 1, 0, 1</span>],</span><br><span class="line">               [<span class="meta">0, 0, 0, 0, 0</span>],</span><br><span class="line">               [<span class="meta">1, 0, 0, 0, 0</span>],</span><br><span class="line">               [<span class="meta">1, 0, 0, 1, 0</span>],</span><br><span class="line">               [<span class="meta">1, 1, 1, 1, 1</span>],</span><br><span class="line">               [<span class="meta">1, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">1, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 1, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 1, 1, 1</span>],</span><br><span class="line">               [<span class="meta">2, 1, 0, 1, 1</span>],</span><br><span class="line">               [<span class="meta">2, 1, 0, 2, 1</span>],</span><br><span class="line">               [<span class="meta">2, 0, 0, 0, 0</span>]]</span><br><span class="line">    X=np.zeros([len(dataSet),<span class="number">4</span>])</span><br><span class="line">    Y=np.zeros(len(dataSet))</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">len(dataSet</span>)):</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="title">range</span>(<span class="params"><span class="number">4</span></span>):</span></span><br><span class="line"><span class="function">            X[i][t]</span>=dataSet[i][t]</span><br><span class="line">        Y[i]=dataSet[i][<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> X,Y</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解经验熵H(x)</span></span><br><span class="line"><span class="function">def <span class="title">empirical_entropy</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    x_value_list </span>= <span class="keyword">set</span>([x[i] <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">x.shape[<span class="number">0</span>]</span>)])</span></span><br><span class="line"><span class="function">    ent </span>= <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        p = <span class="keyword">float</span>(x[x == x_value].shape[<span class="number">0</span>]) / x.shape[<span class="number">0</span>]</span><br><span class="line">        logp = np.log2(p)</span><br><span class="line">        ent -= p * logp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解经验条件熵H(y|x)</span></span><br><span class="line"><span class="function">def <span class="title">empirical_conditional_entropy</span>(<span class="params">x, y</span>):</span></span><br><span class="line"><span class="function">    x_value_list </span>= <span class="keyword">set</span>([x[i] <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">x.shape[<span class="number">0</span>]</span>)])</span></span><br><span class="line"><span class="function">    # <span class="title">print</span>(<span class="params">x_value_list</span>)</span></span><br><span class="line"><span class="function">    ent </span>= <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        sub_y = y[x == x_value]</span><br><span class="line">        temp_ent = empirical_entropy(sub_y)</span><br><span class="line">        ent += (<span class="keyword">float</span>(sub_y.shape[<span class="number">0</span>]) / y.shape[<span class="number">0</span>]) * temp_ent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"><span class="meta"># 求解信息增益</span></span><br><span class="line"><span class="function">def <span class="title">information_gain</span>(<span class="params">x,y</span>):</span></span><br><span class="line"><span class="function">    base_ent </span>= empirical_entropy(y)</span><br><span class="line">    condition_ent = empirical_conditional_entropy(x, y)</span><br><span class="line">    ent_grap = base_ent - condition_ent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent_grap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    X,Y=get_data()</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"X"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(X)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"Y"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(Y)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>,<span class="string">"信息增益"</span>,<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params">X[<span class="number">0</span>].shape[<span class="number">0</span>]</span>):</span></span><br><span class="line"><span class="function">        <span class="title">print</span>(<span class="params"><span class="string">"g(D,A_"</span>+str(i</span>)+"): %.3f " % (<span class="params">information_gain(X[:,i],Y</span>)))</span></span><br></pre></td></tr></table></figure></p>
<p>结果：<br><img src="/2018/10/19/决策树的原理及实现/QQ20181024-133943.png" alt="信息增益算法结果"></p>
<h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><p>信息增益值的大小是相对于训练数据集而言的，并没有绝对意义。在分类问题困难时，也就是说在训练数据集的经验熵大的时候，信息增益值会偏大。反之，信息增益值会偏小。使用信息增益比可以怼这一问题进行校正。这是特征选择的另一准则。</p>
<blockquote>
<p>定义5.3（信息增益比）特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集D的经验熵$H(D)$之比：$$g_R(D,A)=\frac{g(D,A)}{H(D)}$$其中，$H_A(D)=-\sum_{i=1}^{n}log_2\frac{D_i}{D}$，n是特征A取值的个数。</p>
</blockquote>
<h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归地构建决策树。具体方法是：<strong>从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择为止。最后得到一棵决策树。</strong>ID3相当于用<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/3350286?fr=aladdin" target="_blank" rel="noopener">极大似然法</a>进行概率模型的选择。</p>
<blockquote>
<p>算法5.2（ID3算法）<br>输入：训练数据集D，特征集$A$，阈值$\varepsilon$<br>输出：决策树$T$<br>(1)若D中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$。<br>(2)若$A\ne\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(3)否则，按<a href="#信息增益"><strong>算法5.1</strong></a>计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$；<br>(4)<strong>如果$A_g$的信息增益小于阈值$\varepsilon$</strong>，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(5)否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；<br>(6)对$i$个子结点，以$D_i$为训练集，以$A-{A_g}$为特征集，递归地调用步(1)~(5)，得到子树$T_i$，返回$T_i$。</p>
</blockquote>
<h3 id="C4-5的生成算法"><a href="#C4-5的生成算法" class="headerlink" title="C4.5的生成算法"></a>C4.5的生成算法</h3><p>C4.5算法与ID3算法相似，是对其的一种改进，C4.5在生成的过程中，<strong>用信息增益比来选择特征</strong>。</p>
<blockquote>
<p>算法5.3（C4.5的生成算法）<br>输入：训练数据集$D$，特征集$A$，阈值$\varepsilon$；<br>输出：决策树$T$；<br>(1)如果$D$中所有实例属于同一类$C_k$，则置$T$为单结点树，并将$C_k$作为该结点的类，返回$T$；<br>(2)若$A\ne\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(3)否则，按<a href="#信息增益比"><strong>算法5.10</strong></a>计算$A$中各特征对$D$的信息增益比，选择信息增益比最大的特征$A_g$；<br>(4)<strong>如果$A_g$的信息增益小于阈值$\varepsilon$</strong>，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；<br>(5)否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；<br>(6)对$i$个子结点，以$D_i$为训练集，以$A-{A_g}$为特征集，递归地调用步(1)~(5)，得到子树$T_i$，返回$T_i$。</p>
</blockquote>
<h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>决策树通过递归来产生决策树，这样产生的树往往对训练数据分了很精确，但是在未知数据中不准确，即出现过拟合的现象。在决策树学习中将已生成的树进行简化的过程称为<strong>剪枝</strong>，具体地，剪枝从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为叶结点，从而简化决策树模型。</p>
<h3 id="剪枝所用的损失函数"><a href="#剪枝所用的损失函数" class="headerlink" title="剪枝所用的损失函数"></a>剪枝所用的损失函数</h3><p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树$T$的叶结点个数为$|T|$，t是树$T$的叶结点，该叶结点有$N_t$个样本点，其中k类的样本点有$N_{tk}$个，$k=1,2,…,K$，$H_t(T)$为叶结点$t$上的经验熵，$\alpha\ge0$为参数，则决策树学习的损失函数可以定义为$$C_{\alpha}(T)=\sum_{t=1}^{|T|}{N_tH_t(T)+\alpha{|T|}}\tag{5.11}$$其中经验熵为$$H_t(T)=-\sum_{k}\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t}\tag{5.12}$$在损失函数中，将式(5.11)右端的第1项记作$$C(T)=\sum_{t=1}^{|T|}=N_tH_t(T)=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}log\frac{N_{tk}}{N_t}\tag{5.13}$$这时有$$C_{\alpha}(T)=C(T)+\alpha{|T|}\tag{5.14}$$式(5.14)中，$C(T)$表示<strong>模型对训练数据的预测误差</strong>，即模型与训练数据的拟合度。$|T|$表示模型复杂度，参数$\alpha\ge0$控制两者之间的影响。较大的$\alpha$促使选择简单的模型，较大的$\alpha$促使选择较复杂的模型（树）。$\alpha=0$意味着只考虑模型与训练数据的拟合程度，<strong>不考虑模型的复杂度</strong>。</p>
<p>式(5.11)或式(5.14)定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p>
<p>图5.6就是决策树剪枝过程的示意图。<br><img src="/2018/10/19/决策树的原理及实现/WX20181027-180850.png" alt=""></p>
<blockquote>
<p>算法5.4（树的剪枝算法）<br>输入：生成算法产生的整个树$T$，参数$\alpha$；<br>输出：修剪后的子树$T_\alpha$。<br>(1)计算每个结点的经验熵。<br>(2)递归地从树的叶结点向上回缩。<br>设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别是$C_\alpha(T_B)$与$C_\alpha(T_A)$，如果$$C_\alpha(T_A)\le C_\alpha(T_B)\tag{5.15}$$则进行剪枝，即将父结点变成新的叶结点。<br>(3)返回(2)，直至不能继续为止，得到损失函数最小的子树$T_\alpha$。</p>
</blockquote>
<p>注意，式(5.15)只需考虑两个树的损失函数的差，其计算可以在局部进行。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>netycc</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/10/19/决策树的原理及实现/">https://netycc.com/2018/10/19/决策树的原理及实现/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://netycc.com/2018/10/19/决策树的原理及实现/" data-id="cjob2dlps0018e682esllcsqq" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aS2rDQBAFwNz/0g5kFQiS32vJAc3UrIyRkyktmv59fcXn9XPyZ/5+/n3yZ24+GBgYj2W8Ts/fZ46+SdhHv8p5h/8XAwNjA0YeQPPL5aRzRvQ3MTAwME4DZcI4fxIDAwPjE4w8TcyfwcDAwDhnJEVs3oCblbvnpfJttTgGBsYDGe1g4D8/f3C+gYGB8RDG68L5dCutuAkGBsbSjHbp4a4xZ1sSR68PAwNjUcb1pYo8vObjhPo+GBgY2zDaNlbe4p+F3SJkY2BgLM2YLW/lF8rL1zZY128XAwPjsYzZmtdsqDAbeUZJKgYGxgaMJNS2ixSz5YzhkgcGBsbSjOtjxRyWBNZ2LIGBgbEDI0nC8rDbFqhJGhqliRgYGBsw2kZ/krTNXtDwlWFgYCzNaJtun/4+X7aIJhsYGBhLMPIxwGyBrF0Xa1tsbzJcDAyMJRjXr9sml+2As1gIw8DA2IzRjjNvCJGjEQIGBsYOjHZYmAfZvNHWvrjDRhsGBsaijOvpWjsemK1rDNNQDAyMJRhXFh3ubZbN1jUwMDB2YLTBdFZk5oE1L2uLqSwGBsbDGa/ytNdqQ3m7ooGBgbEDox00zhLH9kJX0lAMDIxVGXmQbdtwSSKYv6A3SAwMjA0YbZmaF6X3FrGHv8LAwMAoS9nZMDIvgIt0FwMDYzPGLFCeB808ZcTAwMBoi9i71r/yIvm8hYeBgbE24659jWQkkC975b/CwMBYmvENl+2OdBggrHQAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/机器学习/">机器学习</a><a href="/tags/统计学习方法/">统计学习方法</a><a href="/tags/python/">python</a><a href="/tags/决策树/">决策树</a></div><div class="post-nav"><a class="pre" href="/2018/10/25/2019科大讯飞算法岗校招笔试/">2019科大讯飞算法岗校招笔试</a><a class="next" href="/2018/10/17/朴素贝叶斯法原理及实现/">朴素贝叶斯法原理及实现</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'dCzd3ozN5OlrLCT1FcrMc8D7-gzGzoHsz',
  appKey:'UmIi39gBjdh1Aria4ssShR31',
  placeholder:'欢迎讨论~',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/刷题记录/">刷题记录</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术技巧/">技术技巧</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/课设记录/">课设记录</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/统计学习方法/" style="font-size: 15px;">统计学习方法</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/笔试/" style="font-size: 15px;">笔试</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/K近邻/" style="font-size: 15px;">K近邻</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/Jekyll/" style="font-size: 15px;">Jekyll</a> <a href="/tags/ssh配置/" style="font-size: 15px;">ssh配置</a> <a href="/tags/感知机/" style="font-size: 15px;">感知机</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/显卡驱动配置/" style="font-size: 15px;">显卡驱动配置</a> <a href="/tags/朴素贝叶斯/" style="font-size: 15px;">朴素贝叶斯</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/HMM/" style="font-size: 15px;">HMM</a> <a href="/tags/CWS/" style="font-size: 15px;">CWS</a> <a href="/tags/决策树/" style="font-size: 15px;">决策树</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/10/TensorFlow学习手册（二）/">TensorFlow学习手册（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/09/TensorFlow学习手册（一）/">TensorFlow学习手册（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/31/ubuntu16-04显卡驱动安装及环境配置/">Ubuntu16.04显卡驱动安装及环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/28/隐马尔可夫模型及分词上的实现/">隐马尔可夫模型及分词上的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/25/2019科大讯飞算法岗校招笔试/">2019科大讯飞算法岗校招笔试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/决策树的原理及实现/">决策树的原理及实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/17/朴素贝叶斯法原理及实现/">朴素贝叶斯法原理及实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/16/K近邻算法的原理及实现/">K近邻算法的原理及实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Hexo中文章的两种创建方法及加密/">Hexo中文章的两种创建方法及加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/更改hexo博客中的Mathjax引擎/">更改hexo中的Mathjax引擎</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="博客模板" target="_blank">博客模板</a><ul></ul><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" title="HEXO markdown简明语法" target="_blank">HEXO markdown简明语法</a><ul></ul><a href="http://www.mohu.org/info/symbols/symbols.htm" title="mathjax使用的查阅手册" target="_blank">mathjax使用的查阅手册</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Netycc's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><br/><span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
extensions: ["tex2jax.js"],
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true
},
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>